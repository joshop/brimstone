pointer leveldata // pointers to level data in rom
pointer.pointer patterndata // array of pattern pointers
pointer metadata0 // pointers to each metatile data element
pointer metadata1
pointer metadata2
pointer metadata3
pointer metadata4
pointer.pointer metaspritedata // array of metasprite pointer
array level_shadow[512]@$0300 // the current two screens of level data
array oam[256]@$0200 // oam shadow
//array palette_buffer[24] // holds the palette
// palette layout:
//  0, 1, 2 B0 Tile palettes (set per level)
//  3, 4, 5 B1 etc.
//  6, 7, 8 B2
//  9,10,11 B3
// 12,13,14 S0 Player palette
// 15,16,17 S1 Daggers/HUD and fixed effects
// 18,19,20 S2 Enemies 1 (set per level)
// 21,22,23 S3 Enemies 2
array tile_palette1[3]
array tile_palette2[3]
array tile_palette3[3]
array tile_palette4[3]
array player_palette[3]
array dagger_palette[3]
array enemy_palette1[3]
array enemy_palette2[3]
array attribute_shadow[128]@$0500 // attributes for level_shadow
//byte which_slice // left slice or right slice
byte which_slice
byte ll_slice // leftmost loaded slice
volatile byte breakpt // for debugging
volatile byte nmitodo // update palette | redraw right seam | redraw left seam | redraw full screen | redraw statusbar | unused | unused | nmi-finished
//array statusbar[32] // the tiles that comprise the status bar
word player_x // player x in level
byte player_y // player y in screen
word scroll_x @ $18 // x position of the left side of the screen
word vel_x // x velocity, 8.8
word vel_y // y velocity, 8.8
byte sub_x // lower 8 bits of x
byte sub_y // lower 8 bits of y
byte jump_grace // frames left that you can jump
byte whichnmi // for things that take several frames
byte controller // controller data
bool decompressing // currently decompressing
byte debug @$0696 // for debugging
bool gravity_direction // is gravity down or up
byte new_controller // controller data that was pressed this frame
byte jet_fuel // frames of jetfuel left
byte oam_index // current writing oam index
byte player_health // hits left
byte player_lives // lives left
byte player_iframes // number of invulnerability frames (player flashes)
word level_idx // temporary used throughout code
byte attack_held_frames // number of frames attack button held down
byte attack_frames // for tracking the attack cycle
bool sword_out // unused for now
word sword_x // unused for now
byte sword_y // unused for now
bool player_facing // left or right facing
byte animation_timer // unused for now
byte dash_frames // number of frames remaining in dash cycle
byte dash_direction // direction dashing (ctrlr buttons)
byte subweapon // top 4 bits: weapon type, bottom 4: switch cooldown
array max_subweapons[4] // max of each subweapon
// enemy structure:
// 2 bytes x position
// 1 byte y position
// 1 byte enemy type
// 1 byte enemy health
// 3 bytes of data
array(word) enemy_xs[12] @ $b2
array enemy_ys[12] @ $62
array enemy_types[12] @ $580
array enemy_healths[12] @ $ca
array enemy_data1[12] @ $f1
array enemy_data2[12] @ $6f
array enemy_data3[12] @ $1b
array enemy_tags[12] @ $9d // meta number of spawn location
byte enemy_count @ $9a
array(word) effect_xs[12]
array effect_ys[12]
array effect_sprites[12]
array effect_timers[12]
array effect_flags[12]
// timer is the effect's lifetime, sprite is the base
// effect flags:
// VHBMMDDD
// H: horiz mirror
// V: vert mirror
// B: blink
// M: mode (00: static, 01: 2 cycle, 10: 4 cycle, 11: animation)
// D: duration (no of times to shift it)
array(word) dagger_xs[5]
// TODO: make these bytes, and assume it's on player's screen
array dagger_ys[5]
array dagger_times[5]
array dagger_flags[5]
// SSXXTTTT
// S: state
// (00: free, 01: out, 10: recharge, 11: unavailable)
// X: x velocity
// (00: no x vel, 10: left, 11: right, 01: unused)
// T: dagger type
array dagger_yvels[5]
byte effect_count
array(word) update_queue[16]
// screen locations to be redrawn to VRAM despite not being scrolled in
// one is done per frame, right now
array halves_loaded[4]
// which halves (#s) are loaded into which slots in VRAM
// i.e. starts at 0,1,2,3, then 4,1,2,3 then 4,5,2,3 etc
byte update_queue_len
array size_test[200] // early warning for when i'm hitting high ram limits
const array level0 @$E000 = file("level.bin") // compressed level data
const array enemy_flags = [$d0, $d0, $a0, $d0] // has ai | has collision | invisible | vulnerable
const array enemy_hitboxes = [$22, $22, $00, $11] // x size : y size

// BUG TRACKER

// level_idx = (lo(player_x >> 4) & $1f) | (word(player_y & $f0) << 1)
macro asm void find_level_idx(word ref x, byte ref y, word ref idx) {
    ?LDA x+1
    ?LSR
    ?LDA x
    ?ROR
    ?LSR
    ?LSR
    ?LSR
    ?STA idx
    ?LDA y
    ?AND #$F0
    ?ASL
    ?BCC find_level_idx_skip
    ?INC idx+1
find_level_idx_skip:
    ?ORA idx
    ?STA idx
}
macro asm void find_level_idx_enemy(byte ref id, word ref idx) {
    ?LDA id
    ?ASL
    ?TAX
    ?LDA enemy_xs+1,X
    ?LSR
    ?LDA enemy_xs,X
    ?ROR
    ?LSR
    ?LSR
    ?LSR
    ?STA idx
    ?LDX id
    ?LDA enemy_ys,X
    ?AND #$F0
    ?ASL
    ?BCC find_level_idx_skip
    ?INC idx+1
find_level_idx_skip:
    ORA idx
    STA idx
}
void main() {
    init_rw_memory()
	ppu_ctrl = %10001000 // things disabled
	ppu_mask = %00000110
    enemy_count = 0
    effect_count = 0
    read_level_pointers(pointer.word(level0))
    byte i,j,k
    word l @ $00EB
    int24 temp24
    byte temp_val
    bool on_ground
    size_test[0] = 1 // keep it compiled in
    //palette_buffer[0] = $10 // temporary
    //palette_buffer[3] = $05 // temporary
    //palette_buffer[4] = $16 // temporary
    //palette_buffer[6] = $17
    //palette_buffer[7] = $27
    //palette_buffer[8] = $07
    //palette_buffer[15] = $01
    //palette_buffer[16] = $21
    //palette_buffer[17] = $31
    //palette_buffer[18] = $05
    //palette_buffer[19] = $16
    //palette_buffer[20] = $36
    player_palette[0] = $01
    player_palette[1] = $21
    player_palette[2] = $31
    dagger_palette[0] = $01
    dagger_palette[1] = $21
    dagger_palette[2] = $31
    enemy_palette1[0] = $05
    enemy_palette1[1] = $16
    enemy_palette1[2] = $36
    tile_palette1[0] = $10
    tile_palette2[0] = $05
    tile_palette2[1] = $16
    tile_palette3[0] = $17
    tile_palette3[1] = $27
    tile_palette3[2] = $07
    decompress_half_asm(0) // this function takes care of halves_loaded
    decompress_half_asm(1)
    which_slice = 0
    nmitodo = $90 // update palette and redraw whole screen
    scroll_x = 0
    player_x = $10
    player_y = $30
    player_health = 6
    player_lives = 3
    player_iframes = 0
    gravity_direction = false // going down
    jet_fuel = 0
    update_queue_len = 0
    sword_out = false
    dagger_flags[2] = $c0
    dagger_flags[3] = $c0
    dagger_flags[4] = $c0
    dagger_flags[0] = $00
    dagger_flags[1] = $00
    max_subweapons[0] = 2
    max_subweapons[1] = 1
    max_subweapons[2] = 0
    max_subweapons[3] = 0
    //for i,0,until,32 {
    //    statusbar[i] = 1
    //}
    //statusbar[1] = 2
    //create_enemy(2, $a0, $50)
    ll_slice = -2 // since there's a 2-slice buffer on each end
    while (nmitodo & $10 != 0) { // wait until nmi performed

    }
    while (player_health != 0 && player_y < $f0) { // death conditions: out of hp or falls into a pit
        //s0h_stall()
        //ppu_set_scroll(lo(scroll_x), 0)
        update_oam_list()
        new_controller = controller
        asm {
            LDA #$01
            STA $4016
            STA controller
            LSR
            STA $4016
controller_loop:
            LDA $4016
            LSR
            ROL controller
            BCC controller_loop
        }
        new_controller = controller & (new_controller ^ $ff) // mask out old bits
        //if (controller & $40 == 0) { // ie not holding attack button
            if (controller & 1 != 0) { // left and right motion
                vel_x += $50
            } else if (controller & 2 != 0) {
                vel_x -= $50
            }
        //}
        if (hi(vel_x) & $80 != 0) { // get the facing set correctly
            player_facing = true
        } else if (vel_x != 0) {
            player_facing = false
        }
        if (controller & 4 != 0 && jet_fuel != 0) { // jetpack usage (unused rn)
            vel_y += $90
            jet_fuel -= 1
        } else if (controller & 8 != 0 && jet_fuel != 0) {
            vel_y -= $90
            jet_fuel -= 1
        }
        if (controller & $80 != 0 && jump_grace != 0) { // jumping
            vel_y -= $b0
            if (jump_grace < 7) {
                jump_grace = -10
            }
        }
        //if (new_controller & $40 != 0) { // gravity flipping
        //    gravity_direction = not(gravity_direction) 
        //}
        on_ground = false // will be set later
        if (subweapon & $f0 != 0) {
            subweapon -= $10 // decrement cooldown by a tick
        } else if (new_controller & $10 != 0 && subweapon & $f0 == 0) {
            // needs to be off cooldown to fire dagger or swap subweapons
            // check if any daggers are in play or recharging
            // todo: be more graceful here
            // allow switching in cooldown windows
            for i,0,until,5 {
                j = dagger_flags[i] & $c0
                if (j == $40 || j == $80) {
                    goto subweapon_inuse
                }
            }
            do {
                subweapon += 1
                // change from 4 when more subweapons added
                if (subweapon == 4) {
                    subweapon = 0
                    break
                }
            } while (max_subweapons[subweapon] == 0)
            j = max_subweapons[subweapon]
            for i,0,until,5 {
                if (i < j) {
                    dagger_flags[i] = $00
                } else {
                    dagger_flags[i] = $c0
                }
                dagger_times[i] = $00
            }
            subweapon |= $f0 // re-add cooldown
        }
        label subweapon_inuse
        if ((new_controller & $40 != 0 && controller & $f != 0) && subweapon & $f0 == 0) {
            // attempt to spawn dagger
            for i,0,until,5 {
                if (dagger_flags[i] & $c0 == 0) {
                    break
                }
            }
            if (i != 5) {
                // spawn dagger #i
                j = $40
                if (controller & $2 != 0) {
                    j |= $20
                } else if (controller & $1 != 0) {
                    j |= $30
                }
                dagger_flags[i] = j | (subweapon & $0f)
                dagger_xs[i] = player_x
                dagger_ys[i] = player_y
                // 4 pixels/frame
                if (controller & $8 != 0) {
                    j = -$30
                } else if (controller & $4 != 0) {
                    j = $30
                } else {
                    j = $00
                }
                dagger_yvels[i] = j
                dagger_times[i] = 0
            }
        }
        for i,0,until,5 {
            if (dagger_flags[i] & $c0 == $80) {
                dagger_times[i] -= 1
                if (dagger_times[i] == 0) {
                    dagger_flags[i] = dagger_flags[i] & $3f
                }
            } else if (dagger_flags[i] & $c0 == $40) {
                step_dagger(i)
            }
            
        }
        //if (controller & $40 != 0 && not(sword_out)) { // primary attack
        //    if (attack_held_frames > $20) {
        //        sword_out = true
        //        sword_x = player_x
        //        sword_y = player_y
        //        attack_frames = controller & $0f
        //        attack_held_frames = 0
        //    } else {
        //        attack_held_frames = 1 // prevent secondary attack for now
        //    }
        //} else if (attack_held_frames != 0 && attack_frames == 0) {
        //    attack_frames = 8
        //    attack_held_frames = 0
        //    // todo attack animation
        //}
        //if (attack_frames != 0 && not(sword_out)) { // melee attack code
        //    attack_frames -= 1
        //    if (attack_frames != 0) {
        //        if (player_facing) {
        //            i = enemy_collision(player_x-16, player_y, 16) // check collision w/ weapon
        //        } else {
        //            i = enemy_collision(player_x+16, player_y, 16)
        //        }
        //        if (i != $ff && enemy_healths[i] != 0 && enemy_flags[enemy_types[i]] & $10 != 0) {
        //            enemy_healths[i] -= 1
        //        }
        //    }
        //} else if (sword_out) { // unused
        //    if (attack_frames & 1 != 0) {
        //        sword_x += 3
        //    } else if (attack_frames & 2 != 0) {
        //        sword_x -= 3
        //    }
        //    if (attack_frames & 4 != 0) {
        //        sword_y += 3
        //    } else if (attack_frames & 8 != 0) {
        //        sword_y -= 3
        //    }
        //    if (hi(sword_x - scroll_x) != 0 || (sword_y >= $f0)) {
        //        sword_out = false
        //    }
        //}
        temp24.hiword = player_x // code for adding velocity to position
        temp24.loword.lo = sub_x
        if (vel_x > $7fff) {
            temp24.hiword.hi += $ff
        }
        temp24 += vel_x
        player_x = temp24.hiword
        sub_x = temp24.loword.lo
        j = 0
        k = 0
        level_idx.hi = 0
        if (vel_x != 0) {
            //level_idx = (lo(player_x >> 4) & $1f) | (word(player_y & $f0) << 1) // index in level shadow where tile is found
            find_level_idx(player_x, player_y, level_idx)
            if (hi(vel_x) & $80 == 0) { // moving to right, so offset one to the right
                if (level_idx & 31 == 31) {
                    level_idx -= 32
                }
                level_idx += 1
            }
            // CLC needed to circumvent compiler bug
            asm {
                CLC
            }
            if (solidity[level_shadow[level_idx]] || (player_y & $0f != 0 && solidity[level_shadow[level_idx+32]])) { // collision detect
                k += 1
            }
        }
        if (k != 0) { // collision
            if (hi(vel_x) & $80 != 0) {
                player_x += 16
            }
            player_x.lo &= $f0 // snap
            vel_x = 0
            if (level_shadow[level_idx] == 4) { // spikes that kill you
                player_health = 0
            }
        }
        temp24.loword.hi = player_y // add vely to y pos
        temp24.loword.lo = sub_y
        temp24.loword += vel_y // 16-bit math
        player_y = temp24.loword.hi
        sub_y = temp24.loword.lo
        //level_idx = (lo(player_x >> 4) & $1f) | (word(player_y & $f0) << 1)
        j = 0
        k = 0
        level_idx.hi = 0
        find_level_idx(player_x, player_y, level_idx)
        if (vel_y != 0) {
            asm {
                CLC
            }
            if (hi(vel_y) & $80 == 0) {
                level_idx += 32
            }
            if (level_idx & 31 == 31) { // handle wrapping
                j = level_shadow[level_idx - 31]
            } else {
                j = level_shadow[level_idx + 1]
            }
            if (solidity[level_shadow[level_idx]] || (player_x & $0f != 0 && solidity[j])) {
                k += 1
            }
        }
        if (k != 0) { // collision
            if (hi(vel_y) & $80 != 0) { // hit from above, not on ground
                player_y += 16
                jump_grace = 0
            } else {
                on_ground = true
            }
            player_y &= $f0 // snap
            vel_y = 0
        } else if (solidity[level_shadow[level_idx]]) { // if on ground, replenish stuff (originally had +32)
            on_ground = true
        }
        if (on_ground) {
            jump_grace = 7 // can jump and dash again
            dash_frames = 0
            if (level_shadow[level_idx] == 4 || (player_x & $0f != 0 && j == 4)) { // spikes that kill you
                player_health = 0
            }
        }
        if (jump_grace != 0) { // don't ask me how this works, it handles jumping for different heights
            if (jump_grace > 7) {
                if (controller & $80 == 0) {
                    jump_grace = 0
                } else {
                    jump_grace += 1
                }
            } else {
                jump_grace -= 1
            }
        }// else if (new_controller & $80 != 0 && dash_frames & $80 == 0 && controller & $0f != 0) { // perform dash
        //    dash_frames = $8a // 10 frames of dashing
        //    dash_direction = controller
        //    vel_x = 0
        //    vel_y = 0
        //}
        //dash_frames &= $7f
        if (dash_frames & $7f != 0) { // dash in progress, upper bit is if available
            dash_frames -= 1
            if (dash_frames & 4 == 0) {
                create_effect($0f, player_x, player_y, $10, $20) // flame effect on dash
            }
            if (dash_direction & $8 != 0) { // don't question how it works
                vel_y.hi -= 1
            } else if (dash_direction & $4 != 0) {
                vel_y.hi += 1
            } else {
                vel_y = 0
            }
            if (dash_direction & $2 != 0) {
                vel_x.hi -= 1
            } else if (dash_direction & $1 != 0) {
                vel_x.hi += 1
            } else {
                vel_x = 0
            }
            if (dash_frames & $7f == 0) { // arrest velocity at end of dash
                vel_x = 0
                vel_y = 0
            }
        } else { // no gravity while dashing
            if (gravity_direction) { // apply gravity
                vel_y -= $40
            } else {
                vel_y += $40
            }
            if (vel_x > 0) { // apply drag/friction
                if (hi(vel_x) & $80 != 0) {
                    if (vel_x >> 2 == $4fff) {
                        vel_x += 1
                    } else {
                        vel_x -= vel_x >> 2
                        vel_x.hi -= $c0
                    }
                } else {
                    if (vel_x >> 2 == 0) {
                        vel_x -= 1
                    } else {
                        vel_x -= vel_x >> 2
                    }
                }
            }
        }
        if (player_x - scroll_x < $60) { // scroll forwards 60
            //if (player_x - scroll_x <= $38) { // 38
            //    scroll_x -= 8
            //} else {
            //    scroll_x -= 2
            //}
            scroll_x = player_x - $60
        } else if (player_x - scroll_x > $a0) { // backwards // a0
            //if (player_x - scroll_x >= $c8)  { // c8
            //    scroll_x += 8
            //} else {
            //    scroll_x += 2
            //}
            scroll_x = player_x - $a0
        }
        if (hi(scroll_x) & $80 != 0) { // no scrolling off the left edge 
            scroll_x = 0
        }
        if (hi(scroll_x) >= $07) { // or the right edge
            scroll_x = $0700
        }
        i = 0
        while (i < enemy_count) {
            j = hi(player_x-enemy_xs[i]) // to find if it's too far to stay loaded
            if (enemy_healths[i] == 0 || enemy_healths[i] & $80 != 0 || enemy_ys[i] >= $f0 || (j != 0 && j != $ff)) { // || hi(player_x-enemy_xs[i]) != 0 && hi(player_x-enemy_xs[i]) != $ff
                label bugevade
                if (enemy_healths[i] == 0 && enemy_flags[enemy_types[i]] & $20 == 0) {
                    create_effect($80, enemy_xs[i], enemy_ys[i], $20, 0) // enemy dying from damage
                }
                destroy_enemy(i)
            //} else if (hi(player_x-enemy_xs[i]) == 0 || hi(player_x-enemy_xs[i]) == $ff) {
            //    i += 1
            } else {
                i += 1 // next enemy, don't increment otherwise
            }
        }
        for i,0,until,enemy_count {
            j = enemy_types[i] //  && controller & $20 != 0
            if (enemy_flags[j] & $80 != 0 && (hi(scroll_x-enemy_xs[i]) == 0 || hi(scroll_x-enemy_xs[i]) == $ff)) {
                call(enemy_funcs[j], i) // run enemy ai
            }
            // todo: see if i can get it done better in general
            // compiler's broken so i gotta use inline asm
            // this code finds difference in Xs and stores in l
            asm {
                LDA main$i
                ASL
                TAY
                LDA player_x
                SEC
                SBC $B2, Y
                STA $EB
                LDA player_x + 1
                SBC $B3, Y
                STA $EC
            }
            if ((hi(l) == $ff && lo(l) > $f0) || (hi(l) == 0 && lo(l) < (enemy_hitboxes[j] & $f0) >> 1)) {
                if (player_y - enemy_ys[i] > sbyte(-16) && (player_y - enemy_ys[i]) < sbyte((enemy_hitboxes[j] & $0f) << 3)) {
                    if (dash_frames & $7f != 0) { // dashing overrides collision and does damage
                        if (enemy_healths[i] != 0 && enemy_flags[enemy_types[i]] & $10 != 0) {
                            enemy_healths[i] -= 1
                        }
                        dash_frames &= $7f // you can dash again - mask off bit
                    } else if (enemy_flags[j] & $40 != 0) {
                        call(enemy_cfuncs[j], i) // collision
                    }
                }
            }
        }
        i = 0
        while (i < effect_count) {
            effect_timers[i] -= 1
            if (effect_timers[i] == 0) {
                destroy_effect(i)
            } else {
                i += 1
            }
        }
        //if (nmitodo & $40 != 0) { // decompress it first
        //    i = lo((scroll_x >> 4)) - 1
        //    if (i & $80 != 0) {
        //        i = $1f
        //    }
        //    decompress_and_draw(i)
        //    copy_slice_buffer(i)
        //    which_slice = i & 31
        //}
        //if (nmitodo & $20 != 0) { // likewise
        //    i = lo((scroll_x >> 4)) + 16
        //    decompress_and_draw(i)
        //    copy_slice_buffer(i)
        //    which_slice = i & 31
        //}
        i = (hi(scroll_x + 32) << 1) // the 32 is here for testing and debug
        // actually, it's necessary
        // todo: this might be highly inefficient
        if (lo(scroll_x + 32) & $80 != 0) {
            i |= 1
        }
        if (halves_loaded[(i + 2) & 3] != i + 2) { // if the right half is the wrong one
            decompress_half_asm(i + 2)
            if (i == 0) {
                nmitodo |= $20 // and gotta redraw it if we're at the very start
            }
        } else if (i != 0 && halves_loaded[(i - 1) & 3] != i - 1) { // what abt the left half
            decompress_half_asm(i - 1)
        }
        i = lo(scroll_x >> 4) - ll_slice // todo fix this shit
        // also sign stuff
        // (oldscroll >> 4) == ((lo(scroll_x) >> 4) + 1) & $f
        // (oldscroll >> 4) == ((lo(scroll_x) >> 4) - 1) & $f
        if (i > 2) { // if we need to draw one of the slices
            nmitodo |= $40
            //i = lo((scroll_x >> 4)) - 1
            //if (i & $80 != 0) {
            //    i = $1f
            //}
            //which_slice = i & 31
        } else if (i != 2) {
            nmitodo |= $20
            //i = lo((scroll_x >> 4)) + 16
            //which_slice = i & 31
        }
        animation_timer += 1
        nmitodo |= 1 // nmi needs to be done
        while ((nmitodo & 1) != 0) {} // wait until nmi done
    }
    for i,0,until,32 { // wait some frames
        nmitodo |= 1
        while ((nmitodo & 1) != 0) {} // wait until nmi done
    }
    // reset in software
    asm {
        JMP ($FFFC)
    }
}

void step_dagger(byte i) {
    word a
    byte b
    if (dagger_times[i] & $7f == $7f) {
        dagger_times[i] &= $8f
    }
    b = enemy_collision(dagger_xs[i], dagger_ys[i], 8)
    if (b != $ff && enemy_healths[b] != 0 && enemy_flags[enemy_types[b]] & $10 != 0) {
        enemy_healths[b] -= 1
        dagger_flags[i] = %10000000
        dagger_times[i] = $ff
        return
    }
    dagger_times[i] += 1
    if (dagger_flags[i] & $20 != 0) {
        if (dagger_flags[i] & $10 == 0) {
            dagger_xs[i] -= 3
        } else {
            dagger_xs[i] += 3
        }
    }
    if (dagger_yvels[i] & $80 == 0) {
        dagger_ys[i] += dagger_yvels[i] >> 4
    } else {
        dagger_ys[i] += $f0 | (dagger_yvels[i] >> 4)
        // sign extend
    }
    if (dagger_times[i] == $0c) {
        dagger_times[i] |= $80
        // enable dagger gravity
    }
    if (dagger_times[i] & $80 != 0 && sbyte(dagger_yvels[i]) < $7c) {
        dagger_yvels[i] += 4
    }
    // base dagger velocity: 4p/f
    b = hi(dagger_xs[i]-scroll_x)
    if (dagger_ys[i] > $f0 || (b != $00)) {
        dagger_flags[i] = %10000000
        dagger_times[i] = $ff
        return
    }
    a = dagger_xs[i] // weird compiler bug?
    b = dagger_ys[i]
    level_idx.hi = 0
    find_level_idx(a, b, level_idx)
    if (solidity[level_shadow[level_idx]]) {
        dagger_flags[i] = %10000000
        dagger_times[i] = $ff
        return
    }
    return
    //asm {
    //    dagger_kill:
    //}
    

}
void update_oam_list_old() {
    oam_index = 0
    oam[oam_index] = player_y
    oam_index += 1
    oam[oam_index] = $00
    oam_index += 1
    oam[oam_index] = $00
    oam_index += 1
    oam[oam_index] = lo(player_x - scroll_x)
    oam_index += 1
    oam[oam_index] = player_y+8
    oam_index += 1
    oam[oam_index] = $00
    oam_index += 1
    oam[oam_index] = $80
    oam_index += 1
    oam[oam_index] = lo(player_x - scroll_x)
    oam_index += 1
    oam[oam_index] = player_y
    oam_index += 1
    oam[oam_index] = $00
    oam_index += 1
    oam[oam_index] = $40
    oam_index += 1
    oam[oam_index] = lo(player_x - scroll_x) + 8
    oam_index += 1
    oam[oam_index] = player_y+8
    oam_index += 1
    oam[oam_index] = $00
    oam_index += 1
    oam[oam_index] = $c0
    oam_index += 1
    oam[oam_index] = lo(player_x - scroll_x) + 8
    oam_index += 1
    while (oam_index > $03) {
        oam[oam_index] = $ff
        oam_index += 4
    }
}
void basic_enemy_ai(byte id) {
    bool a, b
    // this is just an optimization goldmine, when you get slowdown go here
    level_idx = (lo(enemy_xs[id] >> 4) & $1f) | (word(enemy_ys[id] & $f0) << 1)
    if (enemy_data1[id] != 0) {
        enemy_ys[id] &= $f0
        // walking state
        // 1. possibly enter running state
        // 2. move
        // 3. collision detect with walls
        // 4. collision detect with floor
        if (player_y - enemy_ys[id] < sbyte(16) && player_y - enemy_ys[id] > sbyte(-16)) {
            if (enemy_data1[id] & $80 != 0) {
                enemy_data1[id] >>= 1
                enemy_data3[id] = 20
                if (player_x < enemy_xs[id]) {
                    enemy_data2[id] = $80
                } else {
                    enemy_data2[id] = 0
                }
                return
            } else if (enemy_data3[id] != 0) {
                enemy_data3[id] -= 1
                return
            }
        } else if (enemy_data1[id] & $40 != 0) {
            enemy_data1[id] <<= 1
            return
        }
        if (enemy_data2[id] != 0) {
            enemy_xs[id] -= 1
            if (enemy_data1[id] & $40 != 0) {
                enemy_xs[id] -= 3
            }
            if (solidity[level_shadow[level_idx]]) {
                enemy_data2[id] <<= 1
                enemy_xs[id].lo &= $f0
                enemy_xs[id] += 16
                if (enemy_data1[id] & $40 != 0) {
                    enemy_data1[id] <<= 1
                }
                return
            }
        } else {
            enemy_xs[id] += 1
            if (enemy_data1[id] & $40 != 0) {
                enemy_xs[id] += 3
            }
            if (solidity[level_shadow[level_idx+1]]) {
                enemy_data2[id] = $80
                enemy_xs[id].lo &= $f0
                if (enemy_data1[id] & $40 != 0) {
                    enemy_data1[id] <<= 1
                }
                return
            }
        }
        level_idx += 32
        if (enemy_data2[id] == 0) {
            level_idx += 1
        }
        a = solidity[level_shadow[level_idx]]
        if (enemy_data2[id] == 0) {
            level_idx -= 1
        } else {
            level_idx += 1
        }
        b = solidity[level_shadow[level_idx]]
        if (not(a || b)) {
            enemy_data1[id] = 0
            enemy_data3[id] = 0
        } else if (not(a) && enemy_data1[id] & $40 == 0) {
            enemy_data2[id] ^= $80
        }
    } else {
        enemy_ys[id] += enemy_data3[id] >> 4
        enemy_data3[id] += 4
        if (solidity[level_shadow[level_idx+32]]) {
            enemy_data1[id] = $80
        }
    }
}
void simple_enemy_ai(byte id) { // todo: abstract out routines like enemy to wall collision
    //level_idx = (lo(enemy_xs[id] >> 4) & $1f) | (word(enemy_ys[id] & $f0) << 1)
    level_idx.hi = 0 // needed for find_level_idx_enemy
    find_level_idx_enemy(id, level_idx)
    if (enemy_data2[id] != 0) { // moving left
        enemy_xs[id] -= 1
        if (solidity[level_shadow[level_idx]]) { // reflect if hits wall
            enemy_data2[id] <<= 1
            enemy_xs[id].lo &= $f0
            enemy_xs[id] += 16 // offset for new position
        }
    } else {
        enemy_xs[id] += 1 // move right
        if (solidity[level_shadow[level_idx+1]]) { // reflect if hits wall
            enemy_data2[id] = $80
            enemy_xs[id].lo &= $f0
        }
    }
    level_idx += 32
    if (enemy_data2[id] == 0) { // find proper level index
        level_idx += 1
    }
    if (not(solidity[level_shadow[level_idx]])) {
        enemy_data2[id] ^= $80 // flip if at edge
    }
    
}
// new enemy ai: projectile
void bullet_enemy_ai(byte id) {
    if (enemy_data2[id] != 0) {
        enemy_xs[id] -= 8
    } else {
        enemy_xs[id] += 8
    }
    level_idx.hi = 0 // needed for find_level_idx_enemy
    find_level_idx_enemy(id, level_idx)
    if (solidity[level_shadow[level_idx]]) {
        enemy_healths[id] = $ff // break on walls
    }
}
void prat_enemy_ai(byte id) {
    if (enemy_data1[id] & $30 == 0) {
        if (enemy_xs[id] > player_x) {
            enemy_xs[id] -= 1
        } else if (enemy_xs[id] < player_x) {
            enemy_xs[id] += 1
        }
        if (enemy_ys[id] > player_y) {
            enemy_ys[id] -= 1
        } else if (enemy_ys[id] < player_y) {
            enemy_ys[id] += 1
        }
    }
    if (enemy_data1[id] & $80 != 0) {
        enemy_data1[id] = 0
    } else {
        enemy_data1[id] += 1
    }
}
void ffloor_enemy_ai(byte id) {
    // place four tiles around it
    // todo: outline setting those tiles in some way
    // also: optimize
    level_idx = (lo(enemy_xs[id] >> 4) & $1f) | (word(enemy_ys[id] & $f0) << 1)
    //find_level_idx(enemy_xs[id], enemy_ys[id], level_idx)
    level_idx += $21
    if (enemy_data1[id] == $40) {
        update_queue[update_queue_len] = level_idx
        level_shadow[level_idx] = $00
        update_queue_len += 1
        update_queue[update_queue_len] = level_idx+1
        level_shadow[level_idx+1] = $00
        update_queue_len += 1
        update_queue[update_queue_len] = level_idx+$20
        level_shadow[level_idx+$20] = $00
        update_queue_len += 1
        update_queue[update_queue_len] = level_idx+$21
        level_shadow[level_idx+$21] = $00
        update_queue_len += 1
        enemy_healths[id] = 0
        return
    }
    if (enemy_data2[id] != 0) {
        enemy_data2[id] -= 1
    }
    if (enemy_data2[id] == $70) {
        update_queue[update_queue_len] = level_idx
        level_shadow[level_idx] = $02
        update_queue_len += 1
        update_queue[update_queue_len] = level_idx+1
        level_shadow[level_idx+1] = $02
        update_queue_len += 1
        update_queue[update_queue_len] = level_idx+$20
        level_shadow[level_idx+$20] = $02
        update_queue_len += 1
        update_queue[update_queue_len] = level_idx+$21
        level_shadow[level_idx+$21] = $02
        update_queue_len += 1
        return
    }
    if (player_x >= enemy_xs[id] && player_x - enemy_xs[id] < 64 && enemy_ys[id] >= player_y && enemy_ys[id] - player_y < 16) {
        enemy_data1[id] += 1
    } else {
        enemy_data1[id] = 0
    }
}
void basic_enemy_collide(byte id) {
    if (player_iframes != 0) {
        return
    }
    player_health -= 1
    player_iframes = 30
}
void sd_enemy_collide(byte id) {
    basic_enemy_collide(id)
    enemy_healths[id] = 0
}
// 0: simple
// 1: rat
// 2: floor
// 3: bullet
const array(function.byte.to.void) enemy_funcs = [simple_enemy_ai.pointer, prat_enemy_ai.pointer, ffloor_enemy_ai.pointer, bullet_enemy_ai.pointer]
const array(function.byte.to.void) enemy_cfuncs = [basic_enemy_collide.pointer, basic_enemy_collide.pointer, basic_enemy_collide.pointer, sd_enemy_collide.pointer]
void create_enemy(byte type, word x, byte y) {
    //return
    enemy_types[enemy_count] = type
    enemy_xs[enemy_count] = x
    enemy_ys[enemy_count] = y
    enemy_healths[enemy_count] = 1
    enemy_data1[enemy_count] = 0
    enemy_data2[enemy_count] = $80
    enemy_count += 1
}
void destroy_enemy(byte id) {
    enemy_count -= 1
    enemy_types[id] = enemy_types[enemy_count]
    enemy_xs[id] = enemy_xs[enemy_count]
    enemy_ys[id] = enemy_ys[enemy_count]
    enemy_healths[id] = enemy_healths[enemy_count]
    enemy_data1[id] = enemy_data1[enemy_count]
    enemy_data2[id] = enemy_data2[enemy_count]
    enemy_data3[id] = enemy_data3[enemy_count]
    enemy_tags[id] = enemy_tags[enemy_count]
}
void create_effect(byte type, word x, byte y, byte timer, byte flags) {
    effect_sprites[effect_count] = type
    effect_xs[effect_count] = x
    effect_ys[effect_count] = y
    effect_timers[effect_count] = timer
    effect_flags[effect_count] = flags
    effect_count += 1
}
void destroy_effect(byte id) {
    effect_count -= 1
    effect_sprites[id] = effect_sprites[effect_count]
    effect_xs[id] = effect_xs[effect_count]
    effect_ys[id] = effect_ys[effect_count]
    effect_timers[id] = effect_timers[effect_count]
    effect_flags[id] = effect_flags[effect_count]
}
void s0h_stall() {
    while (ppu_status & $40 != 0) {}
    while (ppu_status & $40 == 0) {}
}
// 89 - 250 - 903
void draw_metasprite(byte x, byte y, byte type, byte flip) {
    pointer metasprite
    byte count
    byte i
    asm {
        DEC y
        LDA type
        BPL metasprite_no_literal
        LDX oam_index
        LDA y
        STA oam,X
        LDA type
        AND #$7f
        STA oam+1,X
        LDA flip
        STA oam+2,X
        LDA x
        STA oam+3,X
        TXA
        CLC
        ADC #$04
        STA oam_index
        RTS
    metasprite_no_literal:
        ASL
        TAY
        LDA (metaspritedata),Y
        STA metasprite.lo
        INY
        LDA (metaspritedata),Y
        STA metasprite.hi
        LDY #$00
        LDA (metasprite),Y
        STA count
        INY
        LDX oam_index
    metasprite_loop:
        LDA x
        BIT flip
        BVC metasprite_nohflip
        SEC
        SBC (metasprite),Y
        BCC metasprite_skip
        STA oam+3,X
        BCS metasprite_hflip
    metasprite_nohflip:
        CLC
        ADC (metasprite),Y
        BCS metasprite_skip
        STA oam+3,X
    metasprite_hflip:
        INY
        LDA y
        BIT flip
        BPL metasprite_novflip
        SEC
        SBC (metasprite),Y
        STA oam,X
        JMP metasprite_vflip
    metasprite_novflip:
        CLC
        ADC (metasprite),Y
        STA oam,X
    metasprite_vflip:
        INY
        LDA (metasprite),Y
        STA oam+1,X
        INY
        LDA (metasprite),Y
        EOR flip
        STA oam+2,X
        INY
        TXA
        CLC
        ADC #$04
        TAX
        DEC count
        BNE metasprite_loop
        STX oam_index
        RTS
    metasprite_skip:
        TXA
        AND #$fc
        TAX
        TYA
        AND #$fc
        CLC
        ADC #$04
        TAY
        JMP metasprite_loop
    }
}
void draw_metasprite_old(byte x, byte y, byte type, byte flip) { // draw metasprite at screen coordinates x, y 
    pointer metasprite
    byte count
    byte i
    if (type & $80 != $00) {
        oam[oam_index] = y - 1
        oam_index += 1
        oam[oam_index] = type & $7f
        oam_index += 1
        oam[oam_index] = flip
        oam_index += 1
        oam[oam_index] = x
        oam_index += 1
        return
    }
    metasprite = metaspritedata[type]
    count = metasprite[0]
    metasprite += 1
    for i,0,until,count {
        if (flip & $80 == 0) {
            oam[oam_index] = y+metasprite[1]
        } else {
            oam[oam_index] = y-metasprite[1]
        }
        oam[oam_index] -= 1
        oam_index += 1
        oam[oam_index] = metasprite[2]
        oam_index += 1
        oam[oam_index] = metasprite[3] ^ flip
        oam_index += 1
        if (flip & $40 == 0) {
            oam[oam_index] = x+metasprite[0] // todo: this is a bit sketchy, maybe inline this addition?
            asm {
                BCS label(skip_metasprite)
            }
        } else {
            //oam[oam_index] = x-metasprite[0]
            asm {
                LDY #0
                LDA draw_metasprite$x
                SEC
                SBC (draw_metasprite$metasprite), Y
                BCC label(skip_metasprite)
                LDY oam_index
                STA $200, Y
            }
        }
        oam_index += 1
        metasprite += 4
        continue
        asm {
            skip_metasprite:
        }
        oam_index &= $fc
        metasprite += 4
    }
}
const array dagger_anim = [%00000000, %01000000, %11000000, %10000000]
void update_oam_list() { // draw all metasprites to oam
    byte i,j,k,l
    byte origin
    origin = oam_index
    //oam_index = 0
    if (jump_grace != 6) {
        j = 3
    } else if (vel_x == 0) {
        j = 0
    } else if (lo(player_x) & $4 == 0) {
        j = 1
    } else {
        j = 2
    }
    if (player_iframes & 1 == 0) {
        if (player_facing) {
            draw_metasprite(lo(player_x - scroll_x) + 8, player_y, j, $40)
        } else {
            draw_metasprite(lo(player_x - scroll_x), player_y, j, 0)
        }
    }
    if (player_iframes != 0) {
        player_iframes -= 1
    }
    //if (sword_out) { // this part needs to be refactored eventually
    //    if (attack_frames & (attack_frames - 1) == 0) { // orthogonal, but maybe comparisons would be faster
    //        if (attack_frames & $0c != 0) { // vertical
    //            if (attack_frames == 4) {
    //                i = 8
    //                k = $80
    //            } else {
    //                i = 0
    //                k = 0
    //            }
    //            draw_metasprite(lo(sword_x - scroll_x), sword_y + i, $0a, k)
    //        } else {
    //            if (attack_frames == 1) {
    //                i = 8
    //                k = $40
    //            } else {
    //                i = 0
    //                k = 0
    //            }
    //            draw_metasprite(lo(sword_x - scroll_x) + i, sword_y, $09, k)
    //        }
    //    } else {
    //        k = 0
    //        if (attack_frames & $04 != 0) {
    //            i = 8
    //            k |= $80 
    //        } else {
    //            i = 0
    //        }
    //        if (attack_frames & $01 != 0) {
    //            j = 8
    //            k |= $40
    //        } else {
    //            j = 0
    //        }
    //        draw_metasprite(lo(sword_x - scroll_x) + i, sword_y + j, $0b, k)
    //    }
    //} else if (attack_frames != 0) {
    //    if (player_facing) {
    //        draw_metasprite(lo(player_x - scroll_x) - 8, player_y, 4 + (attack_frames >> 1), $40) // attack animation
    //    } else {
    //        draw_metasprite(lo(player_x - scroll_x) + 16, player_y, 4 + (attack_frames >> 1), 0)
    //    }
    //}
    for i,0,until,5 {
        j = (dagger_times[i] >> 2) & 3
        if (dagger_flags[i] & $c0 != $c0) {
            if (dagger_flags[i] & $80 != $00) {
                k = $9e + (dagger_times[i] >> 6)
                j = 0
            } else {
                k = $9c
            }
            // todo: this could probably use a touch-up
            l = (subweapon >> 3) - 16
            if (l & $80 != 0) {
                l = -l
            }
            draw_metasprite((i + 1) << 3, l, k, dagger_anim[j] | 1)
        }
        if (dagger_flags[i] & $c0 != $40) {
            continue
        }
        // dagger spin cycle
        // 00 -> 00
        // 01 -> 10
        // 10 -> 11
        // 11 -> 01
        draw_metasprite(lo(dagger_xs[i] - scroll_x), dagger_ys[i], $9c, dagger_anim[j] | 1)
    }
    // todo: optimize player health code
    if (player_health == 1) {
        draw_metasprite(8, 24, $a3, $01)
        draw_metasprite(16, 24, $a4, $01)
        draw_metasprite(24, 24, $a4, $01)
    } else {
        draw_metasprite(8, 24, $a2, $01)
        if (player_health == 2) {
            draw_metasprite(16, 24, $a4, $01)
            draw_metasprite(24, 24, $a4, $01)
        } else if (player_health == 3) {
            draw_metasprite(16, 24, $a3, $01)
            draw_metasprite(24, 24, $a4, $01)
        } else {
            draw_metasprite(16, 24, $a2, $01)
            if (player_health == 4) {
                draw_metasprite(24, 24, $a4, $01)
            } else if (player_health == 5) {
                draw_metasprite(24, 24, $a3, $01)
            } else {
                draw_metasprite(24, 24, $a2, $01)
            }
        }
    }
    draw_metasprite(40, 24, 30, $00)
    draw_metasprite(54, 24, $9d + player_lives, $01)
    for i,0,until,enemy_count {
        if (enemy_data2[i] & $80 != 0) {
            j = 8
        } else {
            j = 0
        }
        if (hi(enemy_xs[i]-scroll_x+j) == 0 && enemy_flags[enemy_types[i]] & $20 == 0) {
            draw_metasprite(lo(enemy_xs[i] - scroll_x) + j, enemy_ys[i], get_metasprite(i), (enemy_data2[i] & $80) >> 1)
        }
    }
    for i,0,until,effect_count {
        if (hi(effect_xs[i]-scroll_x) == 0 && (effect_flags[i] & $20 == 0 || effect_timers[i] & $01 != 0)) {
            if (effect_flags[i] & $18 != $00) {
                j = effect_timers[i] >> (effect_flags[i] & $07)
                if (effect_flags[i] & $18 == $08) {
                    j &= $03
                } else if (effect_flags[i] & $08 != 0) {
                    j &= $07
                }
            } else {
                j = 0
            }
            draw_metasprite(lo(effect_xs[i] - scroll_x), effect_ys[i], effect_sprites[i] + j, effect_flags[i] & $c0)
        }
    }
    //oam[oam_index] = oam[0] // swap the old sprite zero out, we still need it!
    //oam_index += 1
    //oam[oam_index] = oam[1]
    //oam_index += 1
    //oam[oam_index] = oam[2]
    //oam_index += 1
    //oam[oam_index] = oam[3]
    //oam_index += 1
    while (oam_index != origin) { // fill unused sprites with ff in y
        origin -= 4
        oam[origin] = $ff
    }
    //oam[0] = 7 // and deploy the new sprite zero
    //oam[1] = $1d
    //oam[2] = 0
    //oam[3] = $f7
}
byte get_metasprite(byte id) {
    // todo replace w/ return dispatch when it grows too large, or refactor this whole area
    byte j
    j = enemy_types[id]
    if (j == 0) {
        if (lo(enemy_xs[id]) & $08 != 0) {
            return $0c
        } else {
            return $0d
        }
    }
    if (j == 1) {
        return $0e
    }
    if (j == 3) {
        return $0f
    }
    return $ff
}
byte enemy_collision(word x, byte y, byte size) {
    // don't forget, this function can probably be optimized
    byte i,j
    for i,0,until,enemy_count {
        j = enemy_types[i]
        if (lo(x - enemy_xs[i]) > sbyte(-size) && lo(x - enemy_xs[i]) < sbyte((enemy_hitboxes[j] & $f0) >> 1)) {
            if (y - enemy_ys[i] > sbyte(-size) && (y - enemy_ys[i]) < sbyte((enemy_hitboxes[j] & $0f) << 3)) {
                return i
            }
        }
    }
    return $ff
}

void read_level_pointers(pointer.word level) { // read in the level data pointers
    leveldata = level[0]
    metadata0 = level[1]
    metadata1 = level[2]
    metadata2 = level[3]
    metadata3 = level[4]
    metadata4 = level[5]
    metaspritedata = pointer.pointer(level[6])
    patterndata = pointer.pointer(level[7].pointer)
}
inline asm byte ppu_read_data() { // read a byte from the ppu read port
    ! LDA ppu_data
    ? RTS
}
void irq() {

}
const array(bool) solidity = [false, true, true, false, true, false, false, true, true, true, true, true, false] // whether each metatile is solid
void nmi() {
    byte i, j
    word tempaddr
    bool side
    byte tempval
    array buffer[8]
	ppu_mask = %00000000
	ppu_ctrl = %00001000
    ppu_oam_dma_write(oam.addr.hi)
    if (nmitodo & $80 != 0) { // reupdate palette from buffer
        ppu_set_addr($3f01)
        ppu_write_data(tile_palette1[0])
        ppu_write_data(tile_palette1[1])
        ppu_write_data(tile_palette1[2])
        ppu_write_data($0f)
        ppu_write_data(tile_palette2[0])
        ppu_write_data(tile_palette2[1])
        ppu_write_data(tile_palette2[2])
        ppu_write_data($0f)
        ppu_write_data(tile_palette3[0])
        ppu_write_data(tile_palette3[1])
        ppu_write_data(tile_palette3[2])
        ppu_write_data($0f)
        ppu_write_data(tile_palette4[0])
        ppu_write_data(tile_palette4[1])
        ppu_write_data(tile_palette4[2])
        ppu_write_data($0f)
        ppu_write_data(player_palette[0])
        ppu_write_data(player_palette[1])
        ppu_write_data(player_palette[2])
        ppu_write_data($0f)
        ppu_write_data(dagger_palette[0])
        ppu_write_data(dagger_palette[1])
        ppu_write_data(dagger_palette[2])
        ppu_write_data($0f)
        ppu_write_data(enemy_palette1[0])
        ppu_write_data(enemy_palette1[1])
        ppu_write_data(enemy_palette1[2])
        ppu_write_data($0f)
        ppu_write_data(enemy_palette2[0])
        ppu_write_data(enemy_palette2[1])
        ppu_write_data(enemy_palette2[2])
        nmitodo &= $7f
    }
    if (nmitodo & $70 != 0 && not(decompressing) || whichnmi != 0) { // draw a slice 
        ppu_ctrl = %00001100
        if (whichnmi == 0) {
            if (nmitodo & $20 != 0) {
                which_slice = ll_slice-1
                ll_slice -= 1
            } else if (nmitodo & $40 != 0) {
                which_slice = ll_slice+20
                ll_slice += 1
            }
            which_slice &= $1f
            nmitodo &= $9f
            if (which_slice & 16 == 0) {
                ppu_set_addr($2000 | (which_slice << 1))
            } else {
                ppu_set_addr($2400 | ((which_slice & 15) << 1))
            }
            tempaddr = level_shadow.addr + which_slice
            //ppu_write_data($01)
            //ppu_write_data(statusbar[(which_slice & $f) << 1])
            //tempaddr += 32
            for i,0,until,15 {
                ppu_write_data(metadata0[pointer(tempaddr)[0]])
                ppu_write_data(metadata2[pointer(tempaddr)[0]])
                tempaddr += 32
            }
            whichnmi += 1
        } else if (whichnmi == 1) {
            if (which_slice & 16 == 0) {
                ppu_set_addr($2000 | ((which_slice << 1) | 1))
            } else {
                ppu_set_addr($2400 | (((which_slice & 15) << 1) | 1))
            }
            tempaddr = level_shadow.addr + which_slice
            //ppu_write_data($01)
            //ppu_write_data(statusbar[1 | ((which_slice & $f) << 1)])
            //tempaddr += 32
            for i,0,until,15 {
                ppu_write_data(metadata1[pointer(tempaddr)[0]])
                ppu_write_data(metadata3[pointer(tempaddr)[0]])
                tempaddr += 32
            }
            whichnmi += 1
        } else {
            if (which_slice & 16 == 0) {
                tempaddr = $23c0 | (which_slice >> 1)
            } else {
                tempaddr = $27c0 | ((which_slice & 15) >> 1)
            }
            tempval = (which_slice >> 1)
            for i,0,until,8 {
                ppu_set_addr(tempaddr)
                tempaddr += 8
                ppu_write_data(attribute_shadow[tempval])
                tempval += 16 // was 8
            }
            whichnmi = 0
            if (nmitodo & $10 != 0) {
                which_slice += 1
                if (which_slice == 18) {
                    nmitodo &= $ef
                }
            }
        }
    //} else if (nmitodo & $08 != 0) {
    //    // redraw the status bar
    //    ppu_set_addr($2020)
    //    for i,0,until,32 {
    //        ppu_write_data(statusbar[i])
    //    }
    } else if (update_queue_len != 0) {
        i = update_queue_len - 1
        // format: 0000000I IIIIIIII, flags to add later
        if (lo(update_queue[i]) & $10 == 0) {
            tempaddr = $2000 | ((update_queue[i] & $1ef) << 1)
        } else {
            tempaddr = $2400 | ((update_queue[i] & $1ef) << 1)
        }
        ppu_set_addr(tempaddr)
        tempval = level_shadow[update_queue[i]]
        ppu_write_data(metadata0[tempval])
        ppu_write_data(metadata1[tempval])
        ppu_set_addr(tempaddr+32)
        ppu_write_data(metadata2[tempval])
        ppu_write_data(metadata3[tempval])
        update_queue_len = i
    }
    ppu_set_scroll(lo(scroll_x),0) // scroll properly
    //ppu_set_scroll(0,0) // not using s0h but this is for that if i end up
    if (hi(scroll_x) & 1 == 0) {
	    ppu_ctrl = %10001000
    } else {
        ppu_ctrl = %10001001
    }
    if (nmitodo & $10 != 0) {
        ppu_mask = %00000110
    } else if (player_health == 1) {
	    ppu_mask = %00111110
    } else {
        ppu_mask = %00011110
    }
    nmitodo &= $fe // mark finished bit
}
void decompress_half_asm(byte half_idx) {
    // optimizations on this can include alignment stuff
    // and extracting reused code
    // more intellectual optimizations:
    //
    // idea of a "next screen" byte/info somewhere (like in SMB) that moves a two-screen window forwards
    // how to compute/store?
    // next screen should happen right after the last occurrence on any screen
    // options
    // storing it in ROM with a special movement code would take 32 bytes per level more or less
    // storing it in RAM would take also 32 bytes, and would require a precalculation
    // ROM total would be 256 bytes if i include 8 levels as a baseline
    // RAM would be okay, but would also add ROM for a precalculation routine
    // levels could be prefixed with a 32B table that includes the number of commands to start with on each screen
    // precalc routine would require deduction of sizes of things but would be overall straightforward
    // overall conclusion:
    // either 256B ROM and very little RAM
    // or somewhat less than 256B ROM and 32B RAM
    byte half_lo
    byte i,j
    byte xsize, ysize
    byte left,right
    pointer drawing_to
    pointer prev_drawing_to
    byte current_x, current_y, objs_left
    pointer current_obj
    byte cur_header
    byte temp
    pointer patptr
    asm {
        ?LDA #$01
        ?STA decompressing
        ?LDA half_idx
        ?AND #$03
        ?STA half_lo
        ?ASL
        ?ASL
        ?ASL
        ?STA drawing_to
        ?LDA #hi(level_shadow)
        ?STA drawing_to+1
        ?LDY #$0
        ?LDX #$0
    level_shadow_clear_loop:
        ?LDA #$0
        ?STA (drawing_to), Y
        ?INC drawing_to
        ?BNE level_shadow_clear_skip1
        ?INC drawing_to+1
    level_shadow_clear_skip1:
        ?LDA drawing_to
        ?AND #$7
        ?BNE level_shadow_clear_skip2
        ?LDA drawing_to
        ?CLC
        ?ADC #$18
        ?STA drawing_to
        ?BCC level_shadow_clear_skip2
        ?INC drawing_to+1
    level_shadow_clear_skip2:
        ?INX
        ?BPL level_shadow_clear_loop
        ?LDA leveldata+1
        ?STA current_obj+1
        ?LDX leveldata
        ?INX
        ?BNE current_obj_skip1
        ?INC current_obj+1
    current_obj_skip1:
        ?STX current_obj
        ?LDA (leveldata), Y
        ?STA objs_left
        ?STY current_x
        ?STY current_y
        ?JSR label(main_loop_asm2)
        ?LDA #$00
        ?STA decompressing
        ?LDX half_lo
        ?LDA half_idx
        ?STA halves_loaded,X
        ?LDA #hi(attribute_shadow)
        ?STA drawing_to+1
        ?LDA half_lo
        ?ASL
        ?ASL
        ?TAX
        ?ADC #lo(attribute_shadow)
        ?STA drawing_to
        ?LDA #hi(level_shadow)
        ?STA prev_drawing_to+1
        ?TXA
        ?ASL
        ?ADC #lo(level_shadow)
        ?STA prev_drawing_to
        ?LDX #$0
    attr_loop1:
        ?LDY #$21
        ?LDA (prev_drawing_to), Y
        ?TAY
        ?LDA (metadata4), Y
        ?LSR
        ?ROR
        ?ROR
        ?STA temp
        ?LDY #$20
        ?LDA (prev_drawing_to), Y
        ?TAY
        ?LDA (metadata4), Y
        ?ASL
        ?ASL
        ?ASL
        ?ASL
        ?ORA temp
        ?STA temp
        ?LDY #$1
        ?LDA (prev_drawing_to), Y
        ?TAY
        ?LDA (metadata4), Y
        ?ASL
        ?ASL
        ?ORA temp
        ?STA temp
        ?LDY #$0
        ?LDA (prev_drawing_to), Y
        ?TAY
        ?LDA (metadata4), Y
        ?LDY #$0
        ?ORA temp
        ?STA (drawing_to), Y
        ?INC drawing_to
        ?LDY #$2
        ?LDA drawing_to
        ?AND #$3
        ?CLC
        ?BNE attr_skip1
        ?LDA drawing_to
        ?ADC #12
        ?STA drawing_to
        ?LDY #58
    attr_skip1:
        ?TYA
        ?ADC prev_drawing_to
        ?STA prev_drawing_to
        ?BCC attr_skip2
        ?INC prev_drawing_to+1
    attr_skip2:
        ?INX
        ?CPX #$20
        ?BNE attr_loop1
        ?RTS
    main_loop_asm2:
        ?LDA objs_left
        ?BNE objs_left_skip1
        ?RTS
    objs_left_skip1:
        ?DEC objs_left
        ?LDY #$00
        ?LDA (current_obj), Y
        ?STA cur_header
        ?AND #%11000000
        ?CMP #%01000000
        ?BNE movement_cmd_skip1
        ?LDA cur_header
        ?AND #%00111111
        ?BEQ movement_cmd_skip1
        ?AND #%00111000
        ?LSR
        ?LSR
        ?LSR
        ?TAX
        ?CMP #$4
        ?BCC movement_cmd_skip2
        ?LDA current_x
        ?SBC #%01000000
        ?STA current_x
    movement_cmd_skip2:
        ?TXA
        ?ASL
        ?ASL
        ?ASL
        ?ADC current_x
        ?STA current_x
        ?LDA cur_header
        ?AND #%0000111
        ?TAX
        ?CMP #$4
        ?BCC movement_cmd_skip3
        ?LDA current_y
        ?SBC #%01000000
        ?STA current_y
    movement_cmd_skip3:
        ?TXA
        ?ASL
        ?ASL
        ?ASL
        ?ADC current_y
        ?STA current_y
        ?INC current_obj
        ?BNE current_obj_skip2
        ?INC current_obj+1
    current_obj_skip2:
        ?JMP main_loop_asm2
    movement_cmd_skip1:
        ?INY
        ?LDA (current_obj), Y
        ?LSR
        ?LSR
        ?LSR
        ?LSR
        ?TAX
        ?CMP #$8
        ?BCC offset_skip1
        ?LDA current_x
        ?SBC #$10
        ?STA current_x
        ?CLC
    offset_skip1:
        ?TXA
        ?ADC current_x
        ?STA current_x
        ?LDA (current_obj), Y
        ?AND #%00001111
        ?TAX
        ?CMP #$8
        ?BCC offset_skip2
        ?LDA current_y
        ?SBC #$10
        ?STA current_y
        ?CLC
    offset_skip2:
        ?TXA
        ?ADC current_y
        ?STA current_y
        ?LDA cur_header
        ?AND #%11000000
        ?BNE point_cmd_skip1
        ?LDA current_x
        ?LSR
        ?LSR
        ?LSR
        ?CMP half_idx
        ?BNE point_cmd_skip2
        ?LDA current_x
        ?LDX #$00
    point_cmd_loop:
        ?CMP enemy_tags,X
        ?BEQ point_cmd_skip2
        ?INX
        ?CPX enemy_count
        ?BNE point_cmd_loop
        ?STA enemy_tags,X
    }
    create_enemy(cur_header & %00111111, word(current_x) << 4, current_y << 4)
    asm {
    point_cmd_skip2:
        ?INC current_x
        ?INC current_y
        ?INC current_obj
        ?INC current_obj
        ?JMP main_loop_asm2
    point_cmd_skip1:
        ?LDA cur_header
        ?AND #%11000000
        ?CMP #%10000000
        ?BEQ rect_cmd_run
        ?JMP rect_cmd_skip1
    rect_cmd_run:
        ?INY
        ?LDA (current_obj), Y
        ?LSR
        ?LSR
        ?LSR
        ?LSR
        ?TAX
        ?INX
        ?STX xsize
        ?LDA (current_obj), Y
        ?AND #$0f
        ?TAX
        ?INX
        ?STX ysize
        ?LDA current_x
        ?LSR
        ?LSR
        ?LSR
        ?CMP half_idx
        ?BNE rect_cmd_skip2
        ?LDA current_x
        ?AND #$7
        ?BCS rect_cmd_end1
    rect_cmd_skip2:
        ?BCC rect_cmd_jump
        ?LDA current_x
        ?CLC
        ?ADC xsize
        ?STA current_x
        ?JMP rect_cmd_bail
    rect_cmd_jump:
        ?LDA #$0
    rect_cmd_end1:
        ?STA left
        ?LDA current_x
        ?CLC
        ?ADC xsize
        ?STA current_x
        ?LSR
        ?LSR
        ?LSR
        ?CMP half_idx
        ?BCC rect_cmd_bail
        ?BNE rect_cmd_skip3
        ?LDA current_x
        ?AND #$7
        ?BCS rect_cmd_end2
    rect_cmd_skip3:
        ?LDA #$8
    rect_cmd_end2:
        ?CMP left
        ?BEQ rect_cmd_bail
        ?STA right
        ?LDA #hi(level_shadow)
        ?STA prev_drawing_to+1
        ?LDA half_lo
        ?ASL
        ?ASL
        ?ASL
        ?ADC left
        ?STA temp
        ?LDA current_y
        ?ASL
        ?ASL
        ?ASL
        ?ASL
        ?ASL
        ?BCC rect_cmd_skip4
        ?INC prev_drawing_to+1
        ?CLC
    rect_cmd_skip4:
        ?ADC temp
        ?STA prev_drawing_to
        ?LDA cur_header
        ?AND #%00111111
        ?STA cur_header
        ?LDX left
        ?LDY #$00
    rect_cmd_loop1:
        ?LDA prev_drawing_to
        ?STA drawing_to
        ?LDA prev_drawing_to+1
        ?STA drawing_to+1
        ?INC prev_drawing_to
        ?STY j
    rect_cmd_loop2:
        ?LDA cur_header
        ?STA (drawing_to), Y
        ?LDA drawing_to
        ?CLC
        ?ADC #$20
        ?STA drawing_to
        ?BCC rect_cmd_skip5
        ?INC drawing_to+1
    rect_cmd_skip5:
        ?INC j
        ?LDA j
        ?CMP ysize
        ?BNE rect_cmd_loop2
        ?INX
        ?CPX right
        ?BNE rect_cmd_loop1
    rect_cmd_bail:
        ?LDA current_y
        ?CLC
        ?ADC ysize
        ?STA current_y
        ?LDA current_obj
        ?ADC #$03
        ?STA current_obj
        ?BCC rect_cmd_skip6
        ?INC current_obj+1
    rect_cmd_skip6:
        ?JMP main_loop_asm2
    rect_cmd_skip1:
        ?LDA cur_header
        ?AND #%11000000
        ?CMP #%01000000
        ?BEQ dblk_cmd_go
        ?JMP dblk_cmd_skip1
    dblk_cmd_go:
        ?INY
        ?LDA (current_obj), Y
        ?LSR
        ?LSR
        ?LSR
        ?LSR
        ?TAX
        ?INX
        ?STX xsize
        ?LDA (current_obj), Y
        ?AND #$0f
        ?TAX
        ?INX
        ?STX ysize
        ?LDA current_x
        ?LSR
        ?LSR
        ?LSR
        ?CMP half_idx
        ?BEQ dblk_cmd_skip2
        ?BCC dblk_cmd_skip2
        ?JMP dblk_cmd_bail
    dblk_cmd_skip2:
        ?LDA current_obj
        ?CLC
        ?ADC #$03
        ?STA current_obj
        ?LDA #hi(level_shadow)
        ?STA prev_drawing_to+1
        ?LDA half_lo
        ?ASL
        ?ASL
        ?ASL
        ?STA temp
        ?LDA current_y
        ?ASL
        ?ASL
        ?ASL
        ?ASL
        ?ASL
        ?BCC dblk_cmd_skip3
        ?INC prev_drawing_to+1
        ?CLC
    dblk_cmd_skip3:
        ?ADC temp
        ?STA prev_drawing_to
        ?LDA half_idx
        ?ASL
        ?ASL
        ?ASL
        ?STA temp
        ?LDA current_x
        ?SEC
        ?SBC temp
        ?STA left
        ?LDX #$0
    dblk_cmd_loop1:
        ?LDA prev_drawing_to+1
        ?STA drawing_to+1
        ?LDA prev_drawing_to
        ?STA drawing_to
        ?CLC
        ?ADC #$20
        ?STA prev_drawing_to
        ?BCC dblk_cmd_skip4
        ?INC prev_drawing_to+1
    dblk_cmd_skip4:
        ?LDA #$0
        ?STA j
        ?LDA left
        ?STA right
    dblk_cmd_loop2:
        ?LDA right
        ?CMP #$8
        ?BCS dblk_cmd_skip5
        ?LDY #$0
        ?LDA (current_obj), Y
        ?LDY right
        ?STA (drawing_to), Y
    dblk_cmd_skip5:
        ?INC current_obj
        ?BNE dblk_cmd_skip6
        ?INC current_obj+1
    dblk_cmd_skip6:
        ?INC j
        ?INC right
        ?LDA j
        ?CMP xsize
        ?BNE dblk_cmd_loop2
        ?INX
        ?CPX ysize
        ?BNE dblk_cmd_loop1
        ?LDY #$0
    dblk_cmd_bail:
        ?LDA xsize
        ?CLC
        ?ADC current_x
        ?STA current_x
        ?LDA ysize
        ?ADC current_y
        ?STA current_y
        ?TYA
        ?BEQ dblk_cmd_skip7
        ?LDA current_obj
        ?CLC
        ?ADC #3
        ?STA current_obj
        ?BCC dblk_cmd_skip8
        ?INC current_obj+1
    dblk_cmd_skip8:
        ?LDA #$00
    dblk_cmd_loop3:
        ?LSR xsize
        ?BCC dblk_cmd_skip9
        ?CLC
        ?ADC ysize
    dblk_cmd_skip9:
        ?ASL ysize
        ?LDX xsize
        ?BNE dblk_cmd_loop3
        ?CLC
        ?ADC current_obj
        ?STA current_obj
        ?BCC dblk_cmd_skip10
        ?INC current_obj+1
    dblk_cmd_skip10:
    dblk_cmd_skip7:
        ?JMP main_loop_asm2
    dblk_cmd_skip1:
        ?INY
        ?LDA (current_obj), Y
        ?ASL
        ?TAY
        ?LDA (patterndata), Y
        ?STA patptr
        ?INY
        ?LDA (patterndata), Y
        ?STA patptr+1
        ?LDY #$0
        ?LDA (patptr), Y
        ?LSR
        ?LSR
        ?LSR
        ?LSR
        ?TAX
        ?INX
        ?STX xsize
        ?LDA (patptr), Y
        ?AND #$0f
        ?TAX
        ?INX
        ?STX ysize
        ?LDA cur_header
        ?AND #%00111100
        ?LSR
        ?LSR
        ?TAX
        ?INX
        ?STX left
        ?LDA cur_header
        ?AND #%00000011
        ?TAX
        ?INX
        ?STX right
        ?STY i
        ?LDA current_y
        ?PHA
    patt_cmd_loop1:
        ?PLA
        ?STA current_y
        ?PHA
        ?LDA #$0
        ?STA j
    patt_cmd_loop2:
        ?LDA current_x
        ?LSR
        ?LSR
        ?LSR
        ?CMP half_idx
        ?BEQ patt_cmd_skip1
        ?BCC patt_cmd_skip1
        ?JMP patt_cmd_bail
    patt_cmd_skip1:
        ?LDA current_x
        ?SEC
        ?ADC xsize
        ?LSR
        ?LSR
        ?LSR
        ?CMP half_idx
        ?BCS patt_cmd_run1
        ?JMP patt_cmd_bail
    patt_cmd_run1:
        ?LDA current_x
        ?PHA
        ?LDA current_y
        ?PHA
        ?LDA current_obj
        ?PHA
        ?LDA current_obj+1
        ?PHA
        ?LDA objs_left
        ?PHA
        ?LDA xsize
        ?PHA
        ?LDA ysize
        ?PHA
        ?LDA j
        ?PHA
        ?LDA left
        ?PHA
        ?LDA right
        ?PHA
        ?LDA patptr
        ?PHA
        ?LDA patptr+1
        ?PHA
        ?LDA i
        ?PHA
    patt_cmd_skip2:
        ?LDA patptr+1
        ?STA current_obj+1
        ?LDA patptr
        ?CLC
        ?ADC #2
        ?STA current_obj
        ?BCC patt_cmd_skip3
        ?INC current_obj+1
    patt_cmd_skip3:
        ?LDY #$1
        ?LDA (patptr), Y
        ?AND #%01111111
        ?STA objs_left
        ?JSR label(main_loop_asm2)
        ?PLA
        ?STA i
        ?PLA 
        ?STA patptr+1
        ?PLA
        ?STA patptr
    patt_cmd_skip4:
        ?PLA
        ?STA right
        ?PLA
        ?STA left
        ?PLA
        ?STA j
        ?PLA
        ?STA ysize
        ?PLA
        ?STA xsize
        ?PLA
        ?STA objs_left
        ?PLA
        ?STA current_obj+1
        ?PLA
        ?STA current_obj
        ?PLA
        ?STA current_y
        ?PLA
        ?STA current_x
    patt_cmd_bail:
        ?LDA ysize
        ?CLC
        ?ADC current_y
        ?STA current_y
        ?INC j
        ?LDA j
        ?CMP right
        ?BEQ patt_cmd_end1
        ?JMP patt_cmd_loop2
    patt_cmd_end1:
        ?LDA xsize
        ?CLC
        ?ADC current_x
        ?STA current_x
        ?INC i
        ?LDA i
        ?CMP left
        ?BEQ patt_cmd_end2
        ?JMP patt_cmd_loop1
    patt_cmd_end2:
        ?PLA
        ?LDA current_obj
        ?CLC
        ?ADC #$3
        ?STA current_obj
        ?BCC patt_cmd_skip5
        ?INC current_obj+1
    patt_cmd_skip5:
        ?JMP main_loop_asm2
    }
}
segment(chrrom) const array tiles@$0000 = file("bank0.chr")
