pointer leveldata // pointers to level data in rom
pointer.pointer patterndata // array of pattern pointers
pointer metadata0
pointer metadata1
pointer metadata2
pointer metadata3
pointer metadata4
pointer.pointer metaspritedata // array of metasprite pointer
array slice[16] // current decompressed vertical slice
array attrslice[8] // the attribute data for that slice
array level_shadow[512]@$0300 // the current two screens of level data
array oam[256]@$0200 // oam shadow
array palette_buffer[24] // holds the palette
array attribute_shadow[128] // attributes for level_shadow
byte which_slice // left slice or right slice
volatile byte breakpt // for debugging
volatile byte nmitodo // update palette | redraw left seam | redraw right seam | unused | unused | unused | unused | nmi-finished
word player_x // player x in level
byte player_y // player y in screen
word scroll_x // x position of the left side of the screen
word vel_x // x velocity, 8.8
word vel_y // y velocity, 8.8
byte sub_x // lower 8 bits of x
byte sub_y // lower 8 bits of y
byte jump_grace // frames left that you can jump
byte whichnmi // for things that take several frames
byte controller // controller data
bool decompressing // currently decompressing
byte debug @$0696 // for debugging
bool gravity_direction // is gravity down or up
byte new_controller // controller data that was pressed this frame
byte jet_fuel // frames of jetfuel left
byte oam_index // current writing oam index
byte player_health
byte player_iframes
word level_idx
byte attack_held_frames
byte attack_frames
bool sword_out
word sword_x
byte sword_y
bool player_facing
byte animation_timer
byte dash_frames
byte dash_direction
// enemy structure:
// 2 bytes x position
// 1 byte y position
// 1 byte enemy type
// 1 byte enemy health
// 3 bytes of data
array(word) enemy_xs[12]
array enemy_ys[12]
array enemy_types[12]
array enemy_healths[12]
array enemy_data1[12]
array enemy_data2[12]
array enemy_data3[12]
byte enemy_count
array(word) effect_xs[12]
array effect_ys[12]
array effect_sprites[12]
array effect_timers[12]
byte effect_count
array size_test[200]
const array level0 @$E000 = file("level.bin") // compressed level data
const array enemy_flags = [$c0, $c0] // has ai | has collision 
const array enemy_hitboxes = [$22, $11] // x size : y size 
void main() {
    init_rw_memory()
	ppu_ctrl = %10001000 // things disabled
	ppu_mask = %00011110
    enemy_count = 0
    effect_count = 0
    read_level_pointers(pointer.word(level0))
    byte i,j,k
    byte oldscroll
    int24 temp24
    byte temp_val
    size_test[0] = 1
    palette_buffer[0] = $16 // temporary
    palette_buffer[3] = $06
    palette_buffer[15] = $16
    palette_buffer[16] = $27
    palette_buffer[17] = $18
    redraw_screen()
    nmitodo = $a0 // update palette and redraw right seam
    scroll_x = 0
    set_chr_bank(0)
    player_x = $10
    player_y = $30
    player_health = 5
    player_iframes = 0
    gravity_direction = false // going down
    jet_fuel = 0
    sword_out = false
    //create_enemy(0, $a0, 16)
    while (player_health != 0 && player_y < $f0) {
        oldscroll = lo(scroll_x)
        update_oam_list()
        new_controller = controller
        asm {
            LDA #$01
            STA $4016
            STA controller
            LSR
            STA $4016
controller_loop:
            LDA $4016
            LSR
            ROL controller
            BCC controller_loop
        }
        new_controller = controller & (new_controller ^ $ff) // mask out old bits
        if (attack_held_frames == 0) {
            if (controller & 1 != 0) { // left and right motion
                vel_x += $50
            } else if (controller & 2 != 0) {
                vel_x -= $50
            }
        }
        if (hi(vel_x) & $80 != 0) {
            player_facing = true
        } else if (vel_x != 0) {
            player_facing = false
        }
        if (controller & 4 != 0 && jet_fuel != 0) { // jetpack usage
            vel_y += $40
            jet_fuel -= 1
        } else if (controller & 8 != 0 && jet_fuel != 0) {
            vel_y -= $40
            jet_fuel -= 1
        }
        if (controller & $80 != 0 && jump_grace != 0) { // jumping
            vel_y -= $80
            if (jump_grace < 7) {
                jump_grace = -10
            }
        }
        //if (new_controller & $40 != 0) { // gravity flipping
        //    gravity_direction = not(gravity_direction) 
        //}
        if (controller & $40 != 0 && not(sword_out)) { // primary attack
            if (attack_held_frames > $20) {
                sword_out = true
                sword_x = player_x
                sword_y = player_y
                attack_frames = controller & $0f
                attack_held_frames = 0
            } else {
                attack_held_frames += 1
            }
        } else if (attack_held_frames != 0 && attack_frames == 0) {
            attack_frames = 20
            attack_held_frames = 0
            i = enemy_collision(player_x+16, player_y, 16)
            if (i != $ff && enemy_healths[i] != 0) {
                enemy_healths[i] -= 1
            }
            // todo attack animation
        }
        if (attack_frames != 0 && not(sword_out)) {
            attack_frames -= 1
        } else if (sword_out) {
            if (attack_frames & 1 != 0) {
                sword_x += 3
            } else if (attack_frames & 2 != 0) {
                sword_x -= 3
            }
            if (attack_frames & 4 != 0) {
                sword_y += 3
            } else if (attack_frames & 8 != 0) {
                sword_y -= 3
            }
            if (hi(sword_x - scroll_x) != 0 || (sword_y >= $f0)) {
                sword_out = false
            }
        }
        temp24.hiword = player_x // code for adding velocity to position
        temp24.loword.lo = sub_x
        if (vel_x > $7fff) {
            temp24.hiword.hi += $ff
        }
        temp24 += vel_x
        player_x = temp24.hiword
        sub_x = temp24.loword.lo
        j = 0
        k = 0
        if (vel_x != 0) {
            level_idx = (lo(player_x >> 4) & $1f) | (word(player_y & $f0) << 1) // index in level shadow where tile is found
            if (hi(vel_x) & $80 == 0) { // moving to right, so offset one to the right
                level_idx += 1
            }
            // CLC needed to circumvent compiler bug
            asm {
                CLC 
            }
            if (solidity[level_shadow[level_idx]] || (player_y & $0f != 0 && solidity[level_shadow[level_idx+32]])) { // collision detect
                k += 1
            }
        }
        if (k != 0) { // collision
            if (hi(vel_x) & $80 != 0) {
                player_x += 16
            }
            player_x.lo &= $f0
            vel_x = 0
        }
        temp24.loword.hi = player_y // add vely to y pos
        temp24.loword.lo = sub_y
        temp24.loword += vel_y
        player_y = temp24.loword.hi
        sub_y = temp24.loword.lo
        level_idx = (lo(player_x >> 4) & $1f) | (word(player_y & $f0) << 1)
        j = 0
        k = 0
        if (vel_y != 0) {
            asm {
                CLC
            }
            if (hi(vel_y) & $80 == 0) {
                level_idx += 32
            }
            if (solidity[level_shadow[level_idx]] || (player_x & $0f != 0 && solidity[level_shadow[level_idx+1]])) {
                k += 1
            }
        }
        if (k != 0) { // collision
            if (hi(vel_y) & $80 != 0) {
                player_y += 16
                jump_grace = 0
            } else {
                //jet_fuel = 30
                jump_grace = 7
                dash_frames = 0
            }
            player_y &= $f0
            vel_y = 0
        } else if (solidity[level_shadow[level_idx]]) { // if on ground, replenish stuff (originally had +32)
            jump_grace = 7
            //jet_fuel = 30
            dash_frames = 0
        }
        
        if (jump_grace != 0) { // don't ask me how this works, it handles jumping for different heights
            if (jump_grace > 7) {
                if (controller & $80 == 0) {
                    jump_grace = 0
                } else {
                    jump_grace += 1
                }
            } else {
                jump_grace -= 1
            }
        } else if (new_controller & $80 != 0 && dash_frames & $80 == 0 && controller & $0f != 0) { // perform dash
            dash_frames = $8a
            dash_direction = controller
            vel_x = 0
            vel_y = 0
        }
        if (dash_frames & $7f != 0) {
            dash_frames -= 1
            if (dash_frames & 4 == 0) {
                create_effect($0f, player_x, player_y, $10)
            }
            if (dash_direction & $8 != 0) {
                vel_y.hi -= 1
            } else if (dash_direction & $4 != 0) {
                vel_y.hi += 1
            } else {
                vel_y = 0
            }
            if (dash_direction & $2 != 0) {
                vel_x.hi -= 1
            } else if (dash_direction & $1 != 0) {
                vel_x.hi += 1
            } else {
                vel_x = 0
            }
            if (dash_frames & $7f == 0) {
                vel_x = 0
                vel_y = 0
            }
        } else {
            if (gravity_direction) { // apply gravity
                vel_y -= $20
            } else {
                vel_y += $20
            }
            if (vel_x > 0) { // apply drag/friction
                if (hi(vel_x) & $80 != 0) {
                    if (vel_x >> 2 == $3fff) {
                        vel_x += 1
                    } else {
                        vel_x -= vel_x >> 2
                        vel_x.hi -= $c0
                    }
                } else {
                    if (vel_x >> 2 == 0) {
                        vel_x -= 1
                    } else {
                        vel_x -= vel_x >> 2
                    }
                }
            }
        }
        if (player_x - scroll_x < $40) { // scroll forwards
            if (player_x - scroll_x <= $18) {
                scroll_x -= 8
            } else {
                scroll_x -= 2
            }
        } else if (player_x - scroll_x > $c0) { // backwards
            if (player_x - scroll_x >= $e8)  {
                scroll_x += 8
            } else {
                scroll_x += 2
            }
        }
        if (hi(scroll_x) & $80 != 0) { // no scrolling off the left edge 
            scroll_x = 0
        }
        i = 0
        while (i < enemy_count) {
            if (enemy_healths[i] == 0 || enemy_ys[i] >= $f0 || (hi(player_x-enemy_xs[i]) != 0 && hi(player_x-enemy_xs[i]) != $ff)) {
                destroy_enemy(i)
                if (enemy_healths[i] == 0) {
                    create_effect($0f, enemy_xs[i], enemy_ys[i], $20)
                }
            } else {
                i += 1
            }
        }
        for i,0,until,enemy_count {
            j = enemy_types[i] //  && controller & $20 != 0
            if (enemy_flags[j] & $80 != 0 && (hi(scroll_x-enemy_xs[i]) == 0 || hi(scroll_x-enemy_xs[i]) == $ff)) {
                call(enemy_funcs[j], i)
            }
            if (enemy_flags[j] & $40 != 0) {
                if (lo(player_x - enemy_xs[i]) > sbyte(-16) && lo(player_x - enemy_xs[i]) < sbyte((enemy_hitboxes[j] & $f0) >> 1)) {
                    if (player_y - enemy_ys[i] > sbyte(-16) && (player_y - enemy_ys[i]) < sbyte((enemy_hitboxes[j] & $0f) << 3)) {
                        if (dash_frames & $7f != 0) {
                            if (enemy_healths[i] != 0) {
                                enemy_healths[i] -= 1
                            }
                            dash_frames &= $7f
                        } else {
                            call(enemy_cfuncs[j], i)
                        }
                    }
                }
            }
        }
        i = 0
        while (i < effect_count) {
            effect_timers[i] -= 1
            if (effect_timers[i] == 0) {
                destroy_effect(i)
            } else {
                i += 1
            }
        }
        if ((oldscroll >> 4) == ((lo(scroll_x) >> 4) + 1) & $f) { // if we need to draw one of the slices
            nmitodo |= $40
        } else if ((oldscroll >> 4) == ((lo(scroll_x) >> 4) - 1) & $f) {
            nmitodo |= $20
        }
        if (nmitodo & $40 != 0) { // decompress it first
            i = lo((scroll_x >> 4)) - 1
            decompress_and_draw(i)
            copy_slice_buffer(i)
            which_slice = i & 31
        }
        if (nmitodo & $20 != 0) { // likewise
            i = lo((scroll_x >> 4)) + 16
            decompress_and_draw(i)
            copy_slice_buffer(i)
            which_slice = i & 31
        }
        animation_timer += 1
        nmitodo |= 1
        while ((nmitodo & 1) != 0) {} // wait until nmi done
    }
}
void update_oam_list_old() {
    oam_index = 0
    oam[oam_index] = player_y
    oam_index += 1
    oam[oam_index] = $00
    oam_index += 1
    oam[oam_index] = $00
    oam_index += 1
    oam[oam_index] = lo(player_x - scroll_x)
    oam_index += 1
    oam[oam_index] = player_y+8
    oam_index += 1
    oam[oam_index] = $00
    oam_index += 1
    oam[oam_index] = $80
    oam_index += 1
    oam[oam_index] = lo(player_x - scroll_x)
    oam_index += 1
    oam[oam_index] = player_y
    oam_index += 1
    oam[oam_index] = $00
    oam_index += 1
    oam[oam_index] = $40
    oam_index += 1
    oam[oam_index] = lo(player_x - scroll_x) + 8
    oam_index += 1
    oam[oam_index] = player_y+8
    oam_index += 1
    oam[oam_index] = $00
    oam_index += 1
    oam[oam_index] = $c0
    oam_index += 1
    oam[oam_index] = lo(player_x - scroll_x) + 8
    oam_index += 1
    while (oam_index > $03) {
        oam[oam_index] = $ff
        oam_index += 4
    }
}
void basic_enemy_ai(byte id) {
    bool a, b
    // this is just an optimization goldmine, when you get slowdown go here
    level_idx = (lo(enemy_xs[id] >> 4) & $1f) | (word(enemy_ys[id] & $f0) << 1)
    if (enemy_data1[id] != 0) {
        enemy_ys[id] &= $f0
        // walking state
        // 1. possibly enter running state
        // 2. move
        // 3. collision detect with walls
        // 4. collision detect with floor
        if (player_y - enemy_ys[id] < sbyte(16) && player_y - enemy_ys[id] > sbyte(-16)) {
            if (enemy_data1[id] & $80 != 0) {
                enemy_data1[id] >>= 1
                enemy_data3[id] = 20
                if (player_x < enemy_xs[id]) {
                    enemy_data2[id] = $80
                } else {
                    enemy_data2[id] = 0
                }
                return
            } else if (enemy_data3[id] != 0) {
                enemy_data3[id] -= 1
                return
            }
        } else if (enemy_data1[id] & $40 != 0) {
            enemy_data1[id] <<= 1
            return
        }
        if (enemy_data2[id] != 0) {
            enemy_xs[id] -= 1
            if (enemy_data1[id] & $40 != 0) {
                enemy_xs[id] -= 3
            }
            if (solidity[level_shadow[level_idx]]) {
                enemy_data2[id] <<= 1
                enemy_xs[id].lo &= $f0
                enemy_xs[id] += 16
                if (enemy_data1[id] & $40 != 0) {
                    enemy_data1[id] <<= 1
                }
                return
            }
        } else {
            enemy_xs[id] += 1
            if (enemy_data1[id] & $40 != 0) {
                enemy_xs[id] += 3
            }
            if (solidity[level_shadow[level_idx+1]]) {
                enemy_data2[id] = $80
                enemy_xs[id].lo &= $f0
                if (enemy_data1[id] & $40 != 0) {
                    enemy_data1[id] <<= 1
                }
                return
            }
        }
        level_idx += 32
        if (enemy_data2[id] == 0) {
            level_idx += 1
        }
        a = solidity[level_shadow[level_idx]]
        if (enemy_data2[id] == 0) {
            level_idx -= 1
        } else {
            level_idx += 1
        }
        b = solidity[level_shadow[level_idx]]
        if (not(a || b)) {
            enemy_data1[id] = 0
            enemy_data3[id] = 0
        } else if (not(a) && enemy_data1[id] & $40 == 0) {
            enemy_data2[id] ^= $80
        }
    } else {
        enemy_ys[id] += enemy_data3[id] >> 4
        enemy_data3[id] += 4
        if (solidity[level_shadow[level_idx+32]]) {
            enemy_data1[id] = $80
        }
    }
}
void prat_enemy_ai(byte id) {
    if (enemy_data1[id] & $30 == 0) {
        if (enemy_xs[id] > player_x) {
            enemy_xs[id] -= 1
        } else if (enemy_xs[id] < player_x) {
            enemy_xs[id] += 1
        }
        if (enemy_ys[id] > player_y) {
            enemy_ys[id] -= 1
        } else if (enemy_ys[id] < player_y) {
            enemy_ys[id] += 1
        }
    }
    if (enemy_data1[id] & $80 != 0) {
        enemy_data1[id] = 0
    } else {
        enemy_data1[id] += 1
    }
}
void basic_enemy_collide(byte id) {
    if (player_iframes != 0) {
        return
    }
    player_health -= 1
    player_iframes = 30
}
const array(function.byte.to.void) enemy_funcs = [basic_enemy_ai.pointer, prat_enemy_ai.pointer]
const array(function.byte.to.void) enemy_cfuncs = [basic_enemy_collide.pointer, basic_enemy_collide.pointer]
void create_enemy(byte type, word x, byte y) {
    return
    enemy_types[enemy_count] = type
    enemy_xs[enemy_count] = x
    enemy_ys[enemy_count] = y
    enemy_healths[enemy_count] = 1
    enemy_data1[enemy_count] = 0
    enemy_data2[enemy_count] = $80
    enemy_count += 1
}
void destroy_enemy(byte id) {
    enemy_count -= 1
    enemy_types[id] = enemy_types[enemy_count]
    enemy_xs[id] = enemy_xs[enemy_count]
    enemy_ys[id] = enemy_ys[enemy_count]
    enemy_healths[id] = enemy_healths[enemy_count]
}
void create_effect(byte type, word x, byte y, byte timer) {
    effect_sprites[effect_count] = type
    effect_xs[effect_count] = x
    effect_ys[effect_count] = y
    effect_timers[effect_count] = timer
    effect_count += 1
}
void destroy_effect(byte id) {
    effect_count -= 1
    effect_sprites[id] = effect_sprites[effect_count]
    effect_xs[id] = effect_xs[effect_count]
    effect_ys[id] = effect_ys[effect_count]
    effect_timers[id] = effect_timers[effect_count]
}
void draw_metasprite(byte x, byte y, byte type, byte flip) { // draw metasprite at screen coordinates x, y 
    pointer metasprite
    byte count
    byte i
    metasprite = metaspritedata[type]
    count = metasprite[0]
    metasprite += 1
    for i,0,until,count {
        if (flip & $80 == 0) {
            oam[oam_index] = y+metasprite[1]
        } else {
            oam[oam_index] = y-metasprite[1]
        }
        oam_index += 1
        oam[oam_index] = metasprite[2]
        oam_index += 1
        oam[oam_index] = metasprite[3] ^ flip
        oam_index += 1
        if (flip & $40 == 0) {
            oam[oam_index] = x+metasprite[0]
        } else {
            oam[oam_index] = x-metasprite[0]
        }
        oam_index += 1
        metasprite += 4
    }
}
void update_oam_list() { // draw all metasprites to oam
    byte i,j,k
    oam_index = 0
    if (jump_grace != 6) {
        j = 3
    } else if (vel_x == 0) {
        j = 0
    } else if (lo(player_x) & $4 == 0) {
        j = 1
    } else {
        j = 2
    }
    if (player_iframes & 1 == 0) {
        if (player_facing) {
            draw_metasprite(lo(player_x - scroll_x) + 8, player_y, j, $40)
        } else {
            draw_metasprite(lo(player_x - scroll_x), player_y, j, 0)
        }
    }
    if (player_iframes != 0) {
        player_iframes -= 1
    }
    if (sword_out) { // this part needs to be refactored eventually
        if (attack_frames & (attack_frames - 1) == 0) { // orthogonal, but maybe comparisons would be faster
            if (attack_frames & $0c != 0) { // vertical
                if (attack_frames == 4) {
                    i = 8
                    k = $80
                } else {
                    i = 0
                    k = 0
                }
                draw_metasprite(lo(sword_x - scroll_x), sword_y + i, $0a, k)
            } else {
                if (attack_frames == 1) {
                    i = 8
                    k = $40
                } else {
                    i = 0
                    k = 0
                }
                draw_metasprite(lo(sword_x - scroll_x) + i, sword_y, $09, k)
            }
        } else {
            k = 0
            if (attack_frames & $04 != 0) {
                i = 8
                k |= $80 
            } else {
                i = 0
            }
            if (attack_frames & $01 != 0) {
                j = 8
                k |= $40
            } else {
                j = 0
            }
            draw_metasprite(lo(sword_x - scroll_x) + i, sword_y + j, $0b, k)
        }
    }
    for i,0,until,enemy_count {
        if (hi(enemy_xs[i]-scroll_x) == 0) {
            if (enemy_data2[i] & $80 != 0) {
                j = 8
            } else {
                j = 0
            }
            draw_metasprite(lo(enemy_xs[i] - scroll_x) + j, enemy_ys[i], get_metasprite(i), (enemy_data2[i] & $80) >> 1)
        }
    }
    for i,0,until,effect_count {
        if (hi(effect_xs[i]-scroll_x) == 0) {
            draw_metasprite(lo(effect_xs[i] - scroll_x), effect_ys[i], effect_sprites[i], 0)
        }
    }
    while (oam_index != $00) { // fill unused sprites with ff in y
        oam[oam_index] = $ff
        oam_index += 4
    }
}
byte get_metasprite(byte id) {
    // todo replace w/ return dispatch when it grows too large, or refactor this whole area
    byte j
    j = enemy_types[id]
    if (j == 0) {
        if (lo(enemy_xs[id]) & $08 != 0) {
            return $0c
        } else {
            return $0d
        }
    }
    if (j == 1) {
        return $0e
    }
    return $ff
}
byte enemy_collision(word x, byte y, byte size) {
    byte i,j
    for i,0,until,enemy_count {
        j = enemy_types[i]
        if (lo(x - enemy_xs[i]) > sbyte(-size) && lo(x - enemy_xs[i]) < sbyte((enemy_hitboxes[j] & $f0) >> 1)) {
            if (y - enemy_ys[i] > sbyte(-size) && (y - enemy_ys[i]) < sbyte((enemy_hitboxes[j] & $0f) << 3)) {
                return i
            }
        }
    }
    return $ff
}

void read_level_pointers(pointer.word level) { // read in the level data pointers
    leveldata = level[0]
    metadata0 = level[1]
    metadata1 = level[2]
    metadata2 = level[3]
    metadata3 = level[4]
    metadata4 = level[5]
    metaspritedata = pointer.pointer(level[6])
    patterndata = pointer.pointer(level[7].pointer)
}
inline asm byte ppu_read_data() { // read a byte from the ppu read port
    ! LDA ppu_data
    ? RTS
}
void irq() {

}
const array(bool) solidity = [false, true, true, true, false, false, false, false] // whether each metatile is solid
void nmi() {
    byte i, j
    word tempaddr
    bool side
    byte tempval
    array buffer[8]
	ppu_mask = %00000000
	ppu_ctrl = %00001000
    ppu_oam_dma_write(oam.addr.hi)
    if (nmitodo & $80 != 0) { // reupdate palette from buffer
        ppu_set_addr($3f01)
        ppu_write_data(palette_buffer[0])
        ppu_write_data(palette_buffer[1])
        ppu_write_data(palette_buffer[2])
        ppu_write_data($0f)
        ppu_write_data(palette_buffer[3])
        ppu_write_data(palette_buffer[4])
        ppu_write_data(palette_buffer[5])
        ppu_write_data($0f)
        ppu_write_data(palette_buffer[6])
        ppu_write_data(palette_buffer[7])
        ppu_write_data(palette_buffer[8])
        ppu_write_data($0f)
        ppu_write_data(palette_buffer[9])
        ppu_write_data(palette_buffer[10])
        ppu_write_data(palette_buffer[11])
        ppu_write_data($0f)
        ppu_write_data(palette_buffer[12])
        ppu_write_data(palette_buffer[13])
        ppu_write_data(palette_buffer[14])
        ppu_write_data($0f)
        ppu_write_data(palette_buffer[15])
        ppu_write_data(palette_buffer[16])
        ppu_write_data(palette_buffer[17])
        ppu_write_data($0f)
        ppu_write_data(palette_buffer[18])
        ppu_write_data(palette_buffer[19])
        ppu_write_data(palette_buffer[20])
        ppu_write_data($0f)
        ppu_write_data(palette_buffer[21])
        ppu_write_data(palette_buffer[22])
        ppu_write_data(palette_buffer[23])
        nmitodo &= $7f
    }
    if (nmitodo & $60 != 0 && not(decompressing) || whichnmi != 0) { // draw a slice 
        // THIS IS ALL COMMENTED OUT
        #if 0
        ppu_ctrl = %00001100
        side = nmitodo & $40 != 0
        if (side) {
            tempaddr = $2000 + ((((scroll_x >> 4) - 1) & $1f) << 1)
        } else {
            tempaddr = $2000 + ((((scroll_x >> 4) + 16) & $1f) << 1)
        }
        if (lo(tempaddr) >= $20) {
            tempaddr += $400 - $20
        }
        if (whichnmi == 0) {
            ppu_set_addr(tempaddr)
            for i,0,until,14 {
                ppu_write_data(metadata0[slice[i]])
                ppu_write_data(metadata2[slice[i]])
            }
            whichnmi += 1
            nmitodo &= $9f
        } else if (whichnmi == 1) {
            ppu_set_addr(tempaddr + 1)
            for i,0,until,14 {
                ppu_write_data(metadata1[slice[i]])
                ppu_write_data(metadata3[slice[i]])
            }
            whichnmi = 2
        } else if (whichnmi == 2) {
            if (side && lo(scroll_x) & $10 == 0) {
                tempaddr = $23c0 + (((scroll_x >> 5) - 1) & $0f)
            } else if (side) {
                tempaddr = $23c0 + ((scroll_x >> 5) & $0f)
            } else {
                tempaddr = $23c0 + (((scroll_x >> 5) + 8) & $0f)
            }
            if (lo(tempaddr) >= $c8) {
                tempaddr += $400 - $8
            }
            for i,0,until,8 {
                ppu_set_addr(tempaddr)
                ppu_read_data()
                buffer[i] = ppu_read_data()
                tempaddr += 8
            }
            j = 0
            if ((lo(scroll_x) & $10 == 0 && not(side)) || (lo(scroll_x) & $10 != 0 && side)) {
                tempval = $cc
            } else {
                tempval = $33
            }
            for i,7,downto,0 {
                tempaddr -= 8
                ppu_set_addr(tempaddr)
                ppu_write_data((buffer[i] & tempval) | attrslice[i])
            }
            whichnmi = 0
        }
        #endif
        // END COMMENTED SECTION
        ppu_ctrl = %00001100
        nmitodo &= $9f
        if (whichnmi == 0) {
            if (which_slice & 16 == 0) {
                ppu_set_addr($2000 | (which_slice << 1))
            } else {
                ppu_set_addr($2400 | ((which_slice & 15) << 1))
            }
            for i,0,until,15 {
                ppu_write_data(metadata0[slice[i]])
                ppu_write_data(metadata2[slice[i]])
            }
            whichnmi += 1
        } else if (whichnmi == 1) {
            if (which_slice & 16 == 0) {
                ppu_set_addr($2000 | ((which_slice << 1) | 1))
            } else {
                ppu_set_addr($2400 | (((which_slice & 15) << 1) | 1))
            }
            for i,0,until,15 {
                ppu_write_data(metadata1[slice[i]])
                ppu_write_data(metadata3[slice[i]])
            }
            whichnmi += 1
        } else {
            if (which_slice & 16 == 0) {
                tempaddr = $23c0 | (which_slice >> 1)
            } else {
                tempaddr = $27c0 | ((which_slice & 15) >> 1)
            }
            tempval = (which_slice >> 1)
            for i,0,until,8 {
                ppu_set_addr(tempaddr)
                tempaddr += 8
                ppu_write_data(attribute_shadow[tempval])
                tempval += 16 // was 8
            }
            whichnmi = 0
        }
    }
    ppu_set_scroll(lo(scroll_x),0) // scroll properly
    if (hi(scroll_x) & 1 == 0) {
	    ppu_ctrl = %10001000
    } else {
        ppu_ctrl = %10001001
    }
    if (player_health == 1) {
	    ppu_mask = %00111110
    } else {
        if (attack_frames > 16) {
            ppu_mask = %10011110
        } else if (sword_out) {
            ppu_mask = %01011110 
        } else {
            ppu_mask = %00011110
        }
    }
    nmitodo &= $fe // mark finished bit
}
void decompress_and_draw(byte slice_x) { // decompress an x position and write it to the buffer
    byte current_x, current_y, objs_left
    pointer current_obj
    byte cur_header
    byte temp
    pointer patptr
    byte xsize, ysize
    byte i,j
    byte xloop, yloop
    decompressing = true // so that it doesn't try to draw it yet
    for i,0,until,16 {
        slice[i] = 0 // default
    }
    current_obj = leveldata + 1
    objs_left = leveldata[0] // first byte is count
    current_x = 0
    current_y = 0
    asm {
        JSR label(main_loop_asm)
    }
    // will reach here once decompression done
    if (slice_x & 1 != 0) { // assign proper attribute
        for i,0,until,8 {
            attrslice[i] = (metadata4[slice[(i << 1)]] << 2) | (metadata4[slice[(i << 1) + 1]] << 6)
        }
    } else {
        for i,0,until,8 {
            attrslice[i] = (metadata4[slice[(i << 1)]]) | (metadata4[slice[(i << 1) + 1]] << 4)
        }
    }
    decompressing = false
    asm {
        RTS
        main_loop_asm:
    }
    label main_loop // call stack is used for pattern playback recursion
    if (objs_left == 0) {
        asm {
            RTS
        }
    }
    objs_left -= 1
    cur_header = current_obj[0]
    if (cur_header & %11000000 == %01000000 && cur_header & %00111111 != 0) { // movement command
        temp = (cur_header & %00111000) >> 3
        if (temp > 3) {
            current_x -= 8 << 3
        }
        current_x += temp << 3
        temp = cur_header & %00000111
        if (temp > 3) {
            current_y -= 8 << 3
        }
        current_y += temp << 3
        current_obj += 1
        goto main_loop
    }
    temp = current_obj[1] >> 4 // add the offset if not movement command
    if (temp > 7) {
        current_x -= 16
    }
    current_x += temp
    temp = current_obj[1] & %00001111
    if (temp > 7) {
        current_y -= 16
    }
    current_y += temp
    if (cur_header & %11000000 == 0) { // point command (not really?)
        if (current_x == slice_x) { 
            //slice[current_y] = cur_header & %00111111
            create_enemy(cur_header & %00111111, word(current_x) << 4, current_y << 4)
        }
        current_x += 1
        current_y += 1
        current_obj += 2
        goto main_loop
    }
    if (cur_header & %11000000 == %01000000) { // datablock command
        xsize = (current_obj[2] >> 4) + 1
        ysize = (current_obj[2] & %00001111) + 1
        if (current_x <= slice_x && current_x+xsize > slice_x) {
            current_obj += 3 + slice_x - current_x
            for i,0,until,ysize {
                slice[current_y] = current_obj[0]
                current_obj += xsize
                current_y += 1
            }
            current_obj -= slice_x - current_x
            current_x += xsize
        } else {
            current_obj += 3 + xsize * ysize
            current_x += xsize
            current_y += ysize
        }
        goto main_loop
    }
    if (cur_header & %11000000 == %10000000) { // rectangle command
        xsize = (current_obj[2] >> 4) + 1
        ysize = (current_obj[2] & %00001111) + 1
        if (current_x <= slice_x && current_x+xsize > slice_x) {
            for i,0,until,ysize {
                slice[current_y] = cur_header & %00111111
                current_y += 1
            }
            current_x += xsize
        } else {
            current_x += xsize
            current_y += ysize
        }
        current_obj += 3
        goto main_loop
    }
    // it must be pattern reference
    patptr = patterndata[current_obj[2]]
    xsize = (patptr[0] >> 4) + 1
    ysize = (patptr[0] & %00001111) + 1
    xloop = ((cur_header & %00111100) >> 2) + 1
    yloop = ((cur_header & %00000011)     ) + 1 // made a hacky fix w/o knowing how it works, so might have broken sth
    temp = current_x
    for i,0,until,yloop  {
        current_x = temp
        for j,0,until,xloop {
            if (current_x <= slice_x && current_x + xsize > slice_x) {
                // backup state to the stack
                asm {
                    LDA current_x
                    PHA
                    LDA current_y
                    PHA
                    LDA current_obj
                    PHA
                    LDA current_obj+1
                    PHA
                    LDA objs_left
                    PHA
                    LDA temp
                    PHA
                    LDA xsize
                    PHA
                    LDA ysize
                    PHA
                    LDA i
                    PHA
                }
                if (patptr[1] & $80 != 0) {
                    asm {
                        LDA xloop
                        PHA
                        LDA yloop
                        PHA
                        LDA patptr
                        PHA
                        LDA patptr+1
                        PHA
                        LDA j
                        PHA
                    }
                }
                current_obj = patptr + 2
                objs_left = patptr[1] & %01111111
                asm {
                    JSR label(main_loop_asm)
                }
                if (patptr[1] & $80 != 0) {
                    asm {
                        PLA
                        STA j
                        PLA
                        STA patptr+1
                        PLA
                        STA patptr
                        PLA
                        STA yloop
                        PLA
                        STA xloop
                    }
                }
                asm {
                    PLA
                    STA i
                    PLA
                    STA ysize
                    PLA
                    STA xsize
                    PLA
                    STA temp
                    PLA
                    STA objs_left
                    PLA
                    STA current_obj+1
                    PLA
                    STA current_obj
                    PLA
                    STA current_y
                    PLA
                    STA current_x 
                }
            }
            current_x += xsize
        }
        current_y += ysize
    }
    current_obj += 3
    goto main_loop
}
void copy_slice_buffer(byte slice_x) { // copy slice into the level and attribute shadows
    word i
    byte j
    byte k
    i = (slice_x & $1f)
    for j,0,until,16 {
        level_shadow[i] = slice[j]
        i += 32
    }
    i = (slice_x >> 1)
    k = 0
    if (slice_x & 1 == 0) {
        for j,0,until,8 {
            attribute_shadow[i] = (metadata4[slice[k+1]] << 4) | metadata4[slice[k]] | (attribute_shadow[i] & $cc)
            k += 2
            i += 16 // was 8
        }
    } else {
        for j,0,until,8 {
            attribute_shadow[i] = (metadata4[slice[k+1]] << 6) | (metadata4[slice[k]] << 2) | (attribute_shadow[i] & $33)
            k += 2
            i += 16 // was 8
        }
    }
}
void redraw_screen() { // redraw entire screen from compressed data
    byte i,j
    word tempaddr
    array buffer[8]
	ppu_mask = %00000000
	ppu_ctrl = %00001100
    scroll_x &= $ff00
    for i,0,until,16 {
        if (hi(scroll_x) & 1 == 0) {
            ppu_set_addr($2000 | (i << 1))
        } else {
            ppu_set_addr($2400 | (i << 1))
        }
        decompress_and_draw(i)
        copy_slice_buffer(i)
        for j,0,until,15 {
            ppu_write_data(metadata0[slice[j]])
            ppu_write_data(metadata2[slice[j]])
        }
        if (hi(scroll_x) & 1 == 0) {
            ppu_set_addr($2001 | (i << 1))
        } else {
            ppu_set_addr($2401 | (i << 1))
        }
        for j,0,until,15 {
            ppu_write_data(metadata1[slice[j]])
            ppu_write_data(metadata3[slice[j]])
        }
        if (hi(scroll_x) & 1 == 0) {
            tempaddr = $23c0 | (i >> 1)
        } else {
            tempaddr = $27c0 | (i >> 1)
        }
        for j,0,until,8 {
            ppu_set_addr(tempaddr)
            ppu_read_data()
            buffer[j] = ppu_read_data()
            tempaddr += 8
        }
        if (i & 1 != 0) {
            for j,7,downto,0 {
                tempaddr -= 8
                ppu_set_addr(tempaddr)
                ppu_write_data((buffer[j] & $33) | attrslice[j])
            }
        } else {
            for j,7,downto,0 {
                tempaddr -= 8
                ppu_set_addr(tempaddr)
                ppu_write_data((buffer[j] & $cc) | attrslice[j])
            }
        }
    }
	ppu_ctrl = %10001000
}
segment(chrrom0) const array tiles@$0000 = file("bank0.chr")
