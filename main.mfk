pointer leveldata
pointer.pointer patterndata
pointer metadata0
pointer metadata1
pointer metadata2
pointer metadata3
pointer metadata4
array slice[16]
array attrslice[8]
array level_shadow[512]@$0300
array oam[256]@$0200
array palette_buffer[24]
volatile byte breakpt
volatile byte nmitodo // update palette | redraw left seam | redraw right seam | unused | unused | unused | unused | nmi-finished
word player_x
byte player_y
word scroll_x
word vel_x
word vel_y
byte sub_x
byte sub_y
byte jump_grace
byte whichnmi
byte controller
bool decompressing
byte debug @$0696
const array level0 @$E000 = file("level0.bin")
void main() {
    init_rw_memory()
	ppu_ctrl = %10001000
	ppu_mask = %00011110
    read_level_pointers(pointer.word(level0))
    byte i,j
    byte oldscroll
    int24 temp24
    word orig_x
    byte orig_y
    word level_idx
    palette_buffer[0] = $16
    palette_buffer[3] = $06
    redraw_screen()
    nmitodo = $a0
    scroll_x = 0
    set_chr_bank(0)
    while (true) {
        oldscroll = lo(scroll_x)
        update_oam_list()
        asm {
            LDA #$01
            STA $4016
            STA controller
            LSR
            STA $4016
controller_loop:
            LDA $4016
            LSR
            ROL controller
            BCC controller_loop
        }
        if (controller & 1 != 0) {
            vel_x += $50
        } else if (controller & 2 != 0) {
            vel_x -= $50
        }
        if (controller & 4 != 0) {
            vel_y += $40
        } else if (controller & 8 != 0) {
            vel_y -= $40
        }
        if (controller & $80 != 0 && jump_grace != 0) {
            vel_y -= $80
            if (jump_grace < 7) {
                jump_grace = -10
            }
        }
        orig_x = player_x
        orig_y = player_y
        temp24.hiword = player_x
        temp24.loword.lo = sub_x
        if (vel_x > $7fff) {
            temp24.hiword.hi += $ff
        }
        temp24 += vel_x
        player_x = temp24.hiword
        sub_x = temp24.loword.lo
        temp24.loword.hi = player_y
        temp24.loword.lo = sub_y
        temp24.loword += vel_y
        player_y = temp24.loword.hi
        sub_y = temp24.loword.lo
        if (vel_x > 0) {
            if (vel_x > $7fff) {
                if (vel_x >> 2 == $3fff) {
                    vel_x += 1
                } else {
                    vel_x -= vel_x >> 2
                    vel_x.hi -= $c0
                }
            } else {
                if (vel_x >> 2 == 0) {
                    vel_x -= 1
                } else {
                    vel_x -= vel_x >> 2
                }
            }
        }
        vel_y += $20
        level_idx = (lo(player_x >> 4) & $1f) | (word(player_y & $f0) << 1)
        j = 0
        if (solidity[level_shadow[level_idx]]) {
            j |= $8
        }
        if (lo(player_x) & $0f != 0) {
            if (solidity[level_shadow[level_idx+1]]) {
                j |= $4
            }
        }
        if (player_y & $0f != 0) {
            if (solidity[level_shadow[level_idx+32]]) {
                j |= $2
            }
            if (lo(player_x) & $0f != 0) {
                if (solidity[level_shadow[level_idx+33]]) {
                    j |= $1
                }
            }
        }
        debug = j
        if (j != 0 && j != $a && j != $5) {
            vel_y = 0
            player_y = ((orig_y - 1) | 15) + 1
            level_idx = (lo(player_x >> 4) & $1f) | (word(player_y & $f0) << 1)
        }
        if (j > 3 && j != $c) {
            vel_x = 0
            player_x = orig_x
        }
        if (solidity[level_shadow[level_idx+32]]) {
            jump_grace = 7
        }
        if (jump_grace != 0) {
            if (jump_grace > 7) {
                if (controller & $80 == 0) {
                    jump_grace = 0
                } else {
                    jump_grace += 1
                }
            } else {
                jump_grace -= 1
            }
        }
        if (scroll_x > 0 && player_x - scroll_x < $40) {
            scroll_x -= 1
        } else if (player_x - scroll_x > $c0) {
            scroll_x += 1
        }
        if ((oldscroll >> 4) == ((lo(scroll_x) >> 4) + 1) & $f) {
            nmitodo |= $40
        } else if ((oldscroll >> 4) == ((lo(scroll_x) >> 4) - 1) & $f) {
            nmitodo |= $20
        }
        if (nmitodo & $40 != 0) {
            i = lo((scroll_x >> 4) - 1)
            decompress_and_draw(i)
            copy_slice_buffer(i)
        }
        if (nmitodo & $20 != 0) {
            i = lo((scroll_x >> 4) + 16)
            decompress_and_draw(i)
            copy_slice_buffer(i)
        }
        nmitodo |= 1
        while ((nmitodo & 1) != 0) {}
    }
}
void update_oam_list() {
    byte oam_index
    oam_index = 0
    oam[oam_index] = player_y
    oam_index += 1
    oam[oam_index] = $00
    oam_index += 1
    oam[oam_index] = $00
    oam_index += 1
    oam[oam_index] = lo(player_x - scroll_x)
    oam_index += 1
    oam[oam_index] = player_y+8
    oam_index += 1
    oam[oam_index] = $00
    oam_index += 1
    oam[oam_index] = $80
    oam_index += 1
    oam[oam_index] = lo(player_x - scroll_x)
    oam_index += 1
    oam[oam_index] = player_y
    oam_index += 1
    oam[oam_index] = $00
    oam_index += 1
    oam[oam_index] = $40
    oam_index += 1
    oam[oam_index] = lo(player_x - scroll_x) + 8
    oam_index += 1
    oam[oam_index] = player_y+8
    oam_index += 1
    oam[oam_index] = $00
    oam_index += 1
    oam[oam_index] = $c0
    oam_index += 1
    oam[oam_index] = lo(player_x - scroll_x) + 8
    oam_index += 1
    while (oam_index > $03) {
        oam[oam_index] = $ff
        oam_index += 4
    }
}
void read_level_pointers(pointer.word level) {
    leveldata = level[0]
    metadata0 = level[1]
    metadata1 = level[2]
    metadata2 = level[3]
    metadata3 = level[4]
    metadata4 = level[5]
    patterndata = pointer.pointer(level[6].pointer)
}
inline asm byte ppu_read_data() {
    ! LDA ppu_data
    ? RTS
}
void irq() {

}
const array(bool) solidity = [false, true, true, true, false, false, false, false]
void nmi() {
    byte i, j
    word tempaddr
    bool side
    byte tempval
    array buffer[8]
	ppu_mask = %00000000
	ppu_ctrl = %00001000
    ppu_oam_dma_write(oam.addr.hi)
    if (nmitodo & $80 != 0) {
        ppu_set_addr($3f01)
        ppu_write_data(palette_buffer[0])
        ppu_write_data(palette_buffer[1])
        ppu_write_data(palette_buffer[2])
        ppu_write_data($0f)
        ppu_write_data(palette_buffer[3])
        ppu_write_data(palette_buffer[4])
        ppu_write_data(palette_buffer[5])
        ppu_write_data($0f)
        ppu_write_data(palette_buffer[6])
        ppu_write_data(palette_buffer[7])
        ppu_write_data(palette_buffer[8])
        ppu_write_data($0f)
        ppu_write_data(palette_buffer[9])
        ppu_write_data(palette_buffer[10])
        ppu_write_data(palette_buffer[11])
        ppu_write_data($0f)
        ppu_write_data(palette_buffer[12])
        ppu_write_data(palette_buffer[13])
        ppu_write_data(palette_buffer[14])
        ppu_write_data($0f)
        ppu_write_data(palette_buffer[15])
        ppu_write_data(palette_buffer[16])
        ppu_write_data(palette_buffer[17])
        ppu_write_data($0f)
        ppu_write_data(palette_buffer[18])
        ppu_write_data(palette_buffer[19])
        ppu_write_data(palette_buffer[20])
        ppu_write_data($0f)
        ppu_write_data(palette_buffer[21])
        ppu_write_data(palette_buffer[22])
        ppu_write_data(palette_buffer[23])
        nmitodo &= $7f
    }
    if (nmitodo & $60 != 0 && not(decompressing)) {
        ppu_ctrl = %00001100
        side = nmitodo & $40 != 0
        if (side) {
            tempaddr = $2000 + ((((scroll_x >> 4) - 1) & $1f) << 1)
        } else {
            tempaddr = $2000 + ((((scroll_x >> 4) + 16) & $1f) << 1)
        }
        if (lo(tempaddr) >= $20) {
            tempaddr += $400 - $20
        }
        if (whichnmi == 0) {
            ppu_set_addr(tempaddr)
            for i,0,until,15 {
                ppu_write_data(metadata0[slice[i]])
                ppu_write_data(metadata2[slice[i]])
            }
            whichnmi += 1
            nmitodo &= $9f
        } else if (whichnmi == 1) {
            ppu_set_addr(tempaddr + 1)
            for i,0,until,15 {
                ppu_write_data(metadata1[slice[i]])
                ppu_write_data(metadata3[slice[i]])
            }
            whichnmi = 2
        } else if (whichnmi == 2) {
            if (side && lo(scroll_x) & $10 == 0) {
                tempaddr = $23c0 + (((scroll_x >> 5) - 1) & $0f)
            } else if (side) {
                tempaddr = $23c0 + ((scroll_x >> 5) & $0f)
            } else {
                tempaddr = $23c0 + (((scroll_x >> 5) + 8) & $0f)
            }
            if (lo(tempaddr) >= $c8) {
                tempaddr += $400 - $8
            }
            for i,0,until,8 {
                ppu_set_addr(tempaddr)
                ppu_read_data()
                buffer[i] = ppu_read_data()
                tempaddr += 8
            }
            j = 0
            if ((lo(scroll_x) & $10 == 0 && not(side)) || (lo(scroll_x) & $10 != 0 && side)) {
                tempval = $cc
            } else {
                tempval = $33
            }
            for i,7,downto,0 {
                tempaddr -= 8
                ppu_set_addr(tempaddr)
                ppu_write_data((buffer[i] & tempval) | attrslice[i])
            }
            whichnmi = 0
        }
    }
    ppu_set_scroll(lo(scroll_x),0)
    if (hi(scroll_x) & 1 == 0) {
	    ppu_ctrl = %10001000
    } else {
        ppu_ctrl = %10001001
    }
	ppu_mask = %00011110
    nmitodo &= $fe
}
void decompress_and_draw(byte slice_x) {
    byte current_x, current_y, objs_left
    pointer current_obj
    byte cur_header
    byte temp
    pointer patptr
    byte xsize, ysize
    byte i,j
    byte xloop, yloop
    decompressing = true
    breakpt = slice_x
    for i,0,until,16 {
        slice[i] = 0
    }
    current_obj = leveldata + 1
    objs_left = leveldata[0]
    current_x = 0
    current_y = 0
    asm {
        JSR label(main_loop_asm)
    }
    if (slice_x & 1 != 0) {
        for i,0,until,8 {
            attrslice[i] = (metadata4[slice[(i << 1)]] << 2) | (metadata4[slice[(i << 1) + 1]] << 6)
        }
    } else {
        for i,0,until,8 {
            attrslice[i] = (metadata4[slice[(i << 1)]]) | (metadata4[slice[(i << 1) + 1]] << 4)
        }
    }
    decompressing = false
    asm {
        RTS
        main_loop_asm:
    }
    label main_loop
    if (objs_left == 0) {
        asm {
            RTS
        }
    }
    objs_left -= 1
    cur_header = current_obj[0]
    if (cur_header & %11000000 == %01000000 && cur_header & %00111111 != 0) {
        temp = (cur_header & %00111000) >> 3
        if (temp > 3) {
            current_x -= 8 << 3
        }
        current_x += temp << 3
        temp = cur_header & %00000111
        if (temp > 3) {
            current_y -= 8 << 3
        }
        current_y += temp << 3
        current_obj += 1
        goto main_loop
    }
    temp = current_obj[1] >> 4
    if (temp > 7) {
        current_x -= 16
    }
    current_x += temp
    temp = current_obj[1] & %00001111
    if (temp > 7) {
        current_y -= 16
    }
    current_y += temp
    if (cur_header & %11000000 == 0) {
        if (current_x == slice_x) { 
            slice[current_y] = cur_header & %00111111
        }
        current_x += 1
        current_y += 1
        current_obj += 3
        goto main_loop
    }
    if (cur_header & %11000000 == %01000000) {
        xsize = (current_obj[2] >> 4) + 1
        ysize = (current_obj[2] & %00001111) + 1
        if (current_x <= slice_x && current_x+xsize > slice_x) {
            current_obj += 3 + slice_x - current_x
            for i,0,until,ysize {
                slice[current_y] = current_obj[0]
                current_obj += xsize
                current_y += 1
            }
            current_obj -= slice_x - current_x
            current_x += xsize
        } else {
            current_obj += 3 + xsize * ysize
            current_x += xsize
            current_y += ysize
        }
        goto main_loop
    }
    if (cur_header & %11000000 == %10000000) {
        xsize = (current_obj[2] >> 4) + 1
        ysize = (current_obj[2] & %00001111) + 1
        if (current_x <= slice_x && current_x+xsize > slice_x) {
            for i,0,until,ysize {
                slice[current_y] = cur_header & %00111111
                current_y += 1
            }
            current_x += xsize
        } else {
            current_x += xsize
            current_y += ysize
        }
        current_obj += 3
        goto main_loop
    }
    patptr = patterndata[current_obj[2]]
    xsize = (patptr[0] >> 4) + 1
    ysize = (patptr[0] & %00001111) + 1
    xloop = ((cur_header & %00111100) >> 2) + 1
    yloop = ((cur_header & %00000011)     ) + 1 // made a hacky fix w/o knowing how it works, so might have broken sth
    temp = current_x
    for i,0,until,xloop  {
        current_x = temp
        for j,0,until,yloop {
            if (current_x <= slice_x && current_x + xsize > slice_x) {
                asm {
                    LDA current_x
                    PHA
                    LDA current_y
                    PHA
                    LDA current_obj
                    PHA
                    LDA current_obj+1
                    PHA
                    LDA objs_left
                    PHA
                    LDA i
                    PHA
                    LDA j
                    PHA
                    LDA temp
                    PHA
                    LDA xsize
                    PHA
                    LDA ysize
                    PHA
                    LDA xloop
                    PHA
                    LDA yloop
                    PHA
                    LDA patptr
                    PHA
                    LDA patptr+1
                    PHA
                }
                current_obj = patptr + 2
                objs_left = patptr[1] & %01111111
                asm {
                    JSR label(main_loop_asm)
                }
                asm {
                    PLA
                    STA patptr+1
                    PLA
                    STA patptr
                    PLA
                    STA yloop
                    PLA
                    STA xloop
                    PLA
                    STA ysize
                    PLA
                    STA xsize
                    PLA
                    STA temp
                    PLA
                    STA j
                    PLA
                    STA i
                    PLA
                    STA objs_left
                    PLA
                    STA current_obj+1
                    PLA
                    STA current_obj
                    PLA
                    STA current_y
                    PLA
                    STA current_x 
                }
            }
            current_x += xsize
        }
        current_y += ysize
    }
    current_obj += 3
    goto main_loop
}
void copy_slice_buffer(byte slice_x) {
    word i
    byte j
    i = (slice_x & $1f)
    for j,0,until,16 {
        level_shadow[i] = slice[j]
        i += 32
    }
}
void redraw_screen() {
    byte i,j
    word tempaddr
    array buffer[8]
	ppu_mask = %00000000
	ppu_ctrl = %00001100
    scroll_x &= $ff00
    for i,0,until,16 {
        if (hi(scroll_x) & 1 == 0) {
            ppu_set_addr($2000 | (i << 1))
        } else {
            ppu_set_addr($2400 | (i << 1))
        }
        decompress_and_draw(i)
        copy_slice_buffer(i)
        for j,0,until,15 {
            ppu_write_data(metadata0[slice[j]])
            ppu_write_data(metadata2[slice[j]])
        }
        if (hi(scroll_x) & 1 == 0) {
            ppu_set_addr($2001 | (i << 1))
        } else {
            ppu_set_addr($2401 | (i << 1))
        }
        for j,0,until,15 {
            ppu_write_data(metadata1[slice[j]])
            ppu_write_data(metadata3[slice[j]])
        }
        if (hi(scroll_x) & 1 == 0) {
            tempaddr = $23c0 | (i >> 1)
        } else {
            tempaddr = $27c0 | (i >> 1)
        }
        for j,0,until,8 {
            ppu_set_addr(tempaddr)
            ppu_read_data()
            buffer[j] = ppu_read_data()
            tempaddr += 8
        }
        if (i & 1 != 0) {
            for j,7,downto,0 {
                tempaddr -= 8
                ppu_set_addr(tempaddr)
                ppu_write_data((buffer[j] & $33) | attrslice[j])
            }
        } else {
            for j,7,downto,0 {
                tempaddr -= 8
                ppu_set_addr(tempaddr)
                ppu_write_data((buffer[j] & $cc) | attrslice[j])
            }
        }
    }
	ppu_ctrl = %10001000
}
segment(chrrom0) const array tiles@$0000 = file("bank0.chr")
